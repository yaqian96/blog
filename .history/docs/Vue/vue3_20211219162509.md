---
title: vue3的探讨
date: 2020-5-12 10:55:30
author: 'lyq'
categories:
  - vue
tags: 
  - Vue.js
---
# 一、优化
## 1. 响应式系统提升
```js
vue2在初始化的时候，对data中的每个属性使用definepropery调用getter和setter使之变为响应式对象。如果属性值为对象，还会递归调用defineproperty使之变为响应式对象。
vue3使用proxy对象重写响应式。proxy的性能本来比defineproperty好，proxy可以拦截属性的访问、赋值、删除等操作，不需要初始化的时候遍历所有属性，另外有多层属性嵌套的话，只有访问某个属性的时候，才会递归处理下一级的属性。
```
## 2.编译优化
```js

1. 优化编译和重写虚拟dom，让首次渲染和更新dom性能有更大的提升
2. vue2 通过标记静态根节点,优化 diff 算法
   vue3 标记和提升所有静态根节点,diff 的时候只比较动态节点内容
3. Fragments, 模板里面不用创建唯一根节点,可以直接放同级标签和文本内容
4. 静态提升，
// 当使用 hoistStatic 时,所有静态的节点都被提升到 render 方法之外.只会在应用启动的时候被创建一次,之后使用只需要应用提取的静态节点，随着每次的渲染被不停的复用。
// patch flag, 跳过静态节点,直接对比动态节点
patchFlag 被定义为一个数字枚举类型。
当 patchFlag 的值大于 0 时，代表所对应的元素在 patchVNode 时或 render 时是可以被优化生成或更新的。
当 patchFlag 的值小于 0 时，代表所对应的元素在 patchVNode 时，是需要被 full diff，即进行递归遍历 VNode tree 的比较更新过程。
`vue3`  Compile 过程：baseParse===>transform===>generate
`vue2`  Compile 过程：parse===>optimize===>generate


缓存事件处理函数，cacheHandler,避免每次触发都要重新生成全新的function去更新之前的函数
```
## 3. 源码体积的优化
vue3移除了一些不常用的api，例如：inline-template、filter等
使用tree-shaking
# 二. Vue 3.0 所采用的 Composition Api 与 Vue 2.x使用的Options Api 有什么区别？
```js
Options Api
包含一个描述组件选项（data、methods、props等）的对象 options；
API开发复杂组件，同一个功能逻辑的代码被拆分到不同选项 ；
使用mixin重用公用代码，也有问题：命名冲突，数据来源不清晰；minxin是对组件的方法，钩子函数的合并

composition Api
vue3 新增的一组 api，它是基于函数的 api，可以更灵活的组织组件的逻辑。
解决options api在大型项目中，options api不好拆分和重用的问题。
```
# vue-Router(路由模块的本质 就是建立起url和页面之间的映射关系。)
```js
1. 路由
<router-view></router-view>
<router-link></router-link>
2. 动态路由
 /user/:username	/user/evan============={ username: 'evan' } ========this.$route.params
3. 配置404 Not found路由
{
  // 会匹配所有路径，重定向redirect,别名alias
  path: '*',
  redirect: {
      path: defaultPath
  }
}
4. 跳转的方式
// <router-link :to="...">
// router.push(...)
// 命名的路由，必须传递相对应的参数
router.push({ name: 'user', params: { userId: '123' }})
// 带查询参数，变成 /register?plan=private
router.push({ path: 'register', query: { plan: 'private' }})
5. 模式
  1. 默认hash模式。其区别是#开头，在博客园查看
     Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据
     原理：hash值的变化，会引发一个haschange事件，可以根据hash值的变化，加载不同的DOM.
     location.hash	获取当前的hash值
     location.href 获取完整的URL
      特点：
        兼容低版本
        不太美观
        会覆盖瞄点定位的元素
  2. history模式。history.pushState API 来完成 URL 跳转而无须重新加载页面。
6. 导航守卫
全局守卫：beforeEach(to,from,next) beforeResolve(to,from,next) 同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。
 afterEach(to,from) 
路由独享的守卫：beforeEnter(to,from,next)
组件内的守卫：beforeRouteEnter(to,from,next) beforeRouteUpdate(to,from,next) beforeRouteLeave(to,from,next)
7. 滚动行为
scrollBehavior (to, from, savedPosition) {
  if (savedPosition) {
    return savedPosition
  } else {
    if (from.meta.keepAlive) {
      from.meta.savedPosition = document.body.scrollTop
    }
    return { x: 0, y: to.meta.savedPosition || 0 }
  } 
},
8. 路由懒加载
三种方式：1. vue的异步组件 
         component：resolve=>(require([‘需要加载的路由的地址’])，resolve)
         2. ES6 提出的import方法 
         component：（）=>import(‘需要加载的模块地址’)
         3. webpack的ensure()
         component: r => require.ensure([], () => r(require('@/components/home')), 'demo')
9. 导航错误
import VueRouter from 'vue-router'
const { isNavigationFailure, NavigationFailureType } = VueRouter
// 正在尝试访问 admin 页面
router.push('/admin').catch(failure => {
  if (isNavigationFailure(failure, NavigationFailureType.redirected)) {
    // 向用户显示一个小通知
    showToast('Login in order to access the admin panel')
  }
})
10. $route和$router的区别
$route
route是路由信息对象，里面主要包含路由的一些基本信息，包括name、meta、path、hash、query、params、fullPath、matched、redirectedFrom
$router
router是VueRouter的实例，包含了一些路由的跳转方法，钩子函数等
```
# vuex
```js
state，驱动应用的数据源；
view，以声明方式将 state 映射到视图；
actions，响应在 view 上的用户输入导致的状态变化。单向数据流

modules分别对不同模块的部分进行统一状态管理
原理：
Vuex对象有两个属性，一个是install方法，一个是Store这个类
install方法的作用是将store这个实例挂载到所有的组件上，注意是同一个store实例。
Store这个类拥有commit，dispatch这些方法，Store类里将用户传入的state包装成data，作为new Vue的参数，从而实现了state 值的响应式。
// 导入的过程
1. 安装Vuex，再通过import Vuex from 'vuex'引入
2. 先 var store = new Vuex.Store({…}),再把store作为参数的一个属性值，new Vue({store})
3. 通过Vue.use(Vuex) 使得每个组件都可以拥有store实例
//
class Store{
   constructor(options) {
        this.vm = new Vue({
            data:{
                state:options.state
            }
        })
         // getters
        let getters = options.getter || {}
        this.getters = {}
        Object.keys(getters).forEach(getterName=>{
            Object.defineProperty(this.getters,getterName,{
                get:()=>{
                    return getters[getterName](this.state)
                }
            })
        })
        // muations
        let mutations = options.mutations || {}
        this.mutations = {}
        Object.keys(mutations).forEach(mutationName=>{
            this.mutations[mutationName] = (arg)=> {
                mutations[mutationName](this.state,arg)
            }
        })
        // actions
         let actions = options.actions
        this.actions = {}
        Object.keys(actions).forEach(actionName=>{
            this.actions[actionName] = (arg)=>{
                actions[actionName](this,arg)
            }
        })
    }
    dispatch(method,arg){
        this.actions[method](arg)
    }
    commit(method,arg){
        this.mutations[method](arg)
    }
    get state(){
        return this.vm.state
    }

}
let install = function(){
  Vue.mixin({
    beforeCreate(){
        if (this.$options && this.$options.store){ // 如果是根组件
            this.$store = this.$options.store
        }else { //如果是子组件
            this.$store = this.$parent && this.$parent.$store
        }
    }
    })
}

let Vuex = {
    Store,
    install
}

export default Vuex
4. vue.use()
 1、插件的类型，可以是install方法，也可以是一个包含install方法的对象。
 2、插件只能被安装一次，保证插件列表中不能有重复的插件。
 Vue.use = function(plugin){
	const installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
	if(installedPlugins.indexOf(plugin)>-1){
		return this;
	}
	<!-- 其他参数 -->
	const args = toArray(arguments,1);
	args.unshift(this);
	if(typeof plugin.install === 'function'){
		plugin.install.apply(plugin,args);
	}else if(typeof plugin === 'function'){
		plugin.apply(null,plugin,args);
	}
	installedPlugins.push(plugin);
	return this;
}
5. 父组件和子组件的执行顺序
父beforeCreate-> 父created -> 父beforeMounte -> 子beforeCreate ->子create ->子beforeMount ->子 mounted -> 父mounted
```
# vue-devtool工具
1. https://blog.csdn.net/li22356/article/details/113092495
2. 项目中main.js配置 Vue.config.devtools = true;
# vue的插件和组件的区别
```js
1. 概念
插件通常用来为 Vue 添加全局功能。
组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式。
2. 区别
2.1 编写形式
2.2 注册形式
注册插件的时候，需要在调用 new Vue() 启动应用之前完成
Vue.use会自动阻止多次注册相同插件，只会注册一次
2.3 使用场景
组件 (Component) 是用来构成你的 App 的业务模块，它的目标是 App.vue
插件 (Plugin) 是用来增强你的技术栈的功能模块，它的目标是 Vue 本身
```




