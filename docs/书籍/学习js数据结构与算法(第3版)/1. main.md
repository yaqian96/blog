---
title: 学习js数据结构与算法(第3版)
date: 2021-06-29
permalink:
categories:
  - 学习js数据结构与算法(第3版)
tags:
  - 学习js数据结构与算法(第3版)
---

[TOC]



# 1. js 简介

Apache Cordova ：使用 js html css 搭建一个应用，并生成 apk 文件和 ipa 文件。



## 1.1 JavaScript 数据结构与算法

## 1.2 环境搭建

goole 上边安装 web server
步骤：极简插件网站 https://chrome.zzzmh.cn/
e'x

## 1.3 JavaScript 基础

      js支持delete运算符
      =======真值truthy与假值falsy======
      undefined    false
      null         false
      布尔值        true 是 true，false 是 false
      数           +0、-0 和 NaN 都是 false，其他都是 true
      字符串        如果字符串是空的（长度是 0）就是 false，其他都是 true（长度大于等于 1）
      对象          true
      ========toNumber================
      undefined     NaN
      null          +0
      布尔值         如果是 true，返回 1；如果是 false，返回+0
      数             数对应的值
      ========toPrimitive================
      如果对象的 valueOf 方法的结果是原始值，返回原始值；如果对象的 toString 方法返回原始值，就返回这个值；其他情况都返回一个错误

# 2. ECMAScript 和 TypeScript 概述

## 2.1 ECMAScript 还是 JavaScript

## 2.2 ECMAScript 2015+的功能

## 2.3 介绍 TypeScript

# 3. 数组

## 3.1 为什么用数组

## 3.2 创建和初始化数组

## 3.3 添加元素

      push()
      unshift()

## 3.4 删除元素

      pop()
      shift()

## 3.5 在任意位置添加或删除元素

     splice()

## 3.6 二维和多维数组

```js
for (let i = 0; i < matrix3x3x3.length; i++) {
  for (let j = 0; j < matrix3x3x3[i].length; j++) {
    for (let z = 0; z < matrix3x3x3[i][j].length; z++) {
      console.log(matrix3x3x3[i][j][z]);
    }
  }
}
```

## 3.7 JavaScript 的数组方法参考

## 3.8 类型数组

```js
用于存储单一类型的数据, 主要处理二进制数据;
let myArray = new TypedArray(length);
let length = 5;
let int16 = new Int16Array(length);
let array16 = [];
array16.length = length;
for (let i = 0; i < length; i++) {
  int16[i] = i + 1;
}
console.log(int16);
```

## 3.9 TypeScript 中的数组

```js
interface Person {
  name: string;
  age: number;
}
// const friends: {name: string, age: number}[];
const friends = [
  { name: "John", age: 30 },
  { name: "Ana", age: 20 },
  { name: "Chris", age: 25 },
];
function comparePerson(a: Person, b: Person) {
  // comparePerson 函数的内容
}
```

# 4. 栈

## 4.2 栈数据结构

```js
 后进先出
 应用：编程语言的编译器和内存中保存变量、方法调用等，也被用于浏览器历史记录（浏览器的返回按钮）
 // 创建一个基于数组的栈
 class Stack {
    constructor() {
    this.items = []; // {1}
    }
  }
push(element(s))：添加一个（或几个）新元素到栈顶。
pop()：移除栈顶的元素，同时返回被移除的元素。
peek()：返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）。
isEmpty()：如果栈里没有任何元素就返回 true，否则返回 false。
clear()：移除栈里的所有素。
size()：返回栈里的元素个数。该方法和数组的 length 属性很类似。
// 使用Stack类
const stack = new Stack();
console.log(stack.isEmpty());
```

## 4.3 创建一个基于 JavaScript 对象的 Stack 类

```js
class Stack {
  constructor() {
    this.count = 0;
    this.items = {};
  }
  push(element) {
    this.items[this.count] = element;
    this.count++;
  }
  size() {
    return this.count;
  }
  isEmpty() {
    return this.count === 0;
  }
  pop() {
    if (this.isEmpty()) {
      // {1}
      return undefined;
    }
    this.count--; // {2}
    const result = this.items[this.count]; // {3}
    delete this.items[this.count]; // {4}
    return result; // {5}
  }
  peek() {
    if (this.isEmpty()) {
      return undefined;
    }
    return this.items[this.count - 1];
  }
  clear() {
    this.items = {};
    this.count = 0;
  }
  toString() {
    if (this.isEmpty()) {
      return "";
    }
    let objString = `${this.items[0]}`; // {1}
    for (let i = 1; i < this.count; i++) {
      // {2}
      objString = `${objString},${this.items[i]}`; // {3}
    }
    return objString;
  }
}
```

## 4.4 保护数据结构内部元素

下划线命名私有属性
用 ES2015 的限定作用域 Symbol 实现类
用 ES2015 的 WeakMap 实现类
ECMAScript 类属性提案

## 4.5 用栈解决的问题

```js
1. 从十进制到任意进制
function baseConverter(decNumber, base) {
 const remStack = new Stack();
 const digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; // {6}
 let number = decNumber;
 let rem;
 let baseString = '';
 if (!(base >= 2 && base <= 36)) {
    return '';
 }
 while (number > 0) {
    rem = Math.floor(number % base);
    remStack.push(rem);
    number = Math.floor(number / base);
 }
 while (!remStack.isEmpty()) {
    baseString += digits[remStack.pop()]; // {7}
 }
 return baseString;
}
```

# 5. 队列和双端队列

## 5.1 队列数据结构

```js
先进先出，队列在尾部添加新元素，并从顶部移除元素。
enqueue(element(s))：向队列尾部添加一个（或多个）新的项。
dequeue()：移除队列的第一项（即排在队列最前面的项）并返回被移除的元素。
peek()：返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息——与 Stack 类的 peek 方法非常类似）。该方法在其他语言中也可以叫作 front 方法。
isEmpty()：如果队列中不包含任何元素，返回 true，否则返回 false。
size()：返回队列包含的元素个数，与数组的 length 属性类似。
class Queue {
 constructor() {
 this.count = 0; // {1}
 this.lowestCount = 0; // {2}
 this.items = {}; // {3}
  enqueue(element) {
  this.items[this.count] = element;
  this.count++;
  }
  dequeue() {
  if (this.isEmpty()) {
  return undefined;
  }
  const result = this.items[this.lowestCount]; // {1}
  delete this.items[this.lowestCount]; // {2}
  this.lowestCount++; // {3}
  return result; // {4}
  }
  peek() {
  if (this.isEmpty()) {
  return undefined;
  }
  return this.items[this.lowestCount];
  }
  isEmpty() {
    return this.count - this.lowestCount === 0;
  }
  size() {
    return this.count - this.lowestCount;
  }
  clear() {
    this.items = {};
    this.count = 0;
    this.lowestCount = 0;
  }
  toString() {
    if (this.isEmpty()) {
    return '';
    }
    let objString = `${this.items[this.lowestCount]}`;
    for (let i = this.lowestCount + 1; i < this.count; i++) {
    objString = `${objString},${this.items[i]}`;
    }
    return objString;
    }
 }
}
```

## 5.2 双端队列数据结构

```js
// 允许我们同时从前端和后端添加和移除元素的特殊队列
addFront(element)：该方法在双端队列前端添加新的元素。
addBack(element)：该方法在双端队列后端添加新的元素（实现方法和 Queue 类中的enqueue 方法相同）。
removeFront()：该方法会从双端队列前端移除第一个元素（实现方法和 Queue 类中的dequeue 方法相同）。
removeBack()：该方法会从双端队列后端移除第一个元素（实现方法和 Stack 类中的pop 方法一样）。
peekFront()：该方法返回双端队列前端的第一个元素（实现方法和 Queue 类中的 peek方法一样）。
peekBack()：该方法返回双端队列后端的第一个元素（实现方法和 Stack 类中的 peek方法一样）。
class Deque {
 constructor() {
  this.count = 0;
  this.lowestCount = 0;
  this.items = {};
  }
}
```

## 5.3 使用队列和双端队列来解决问题

```js
1. 击鼓传花
2. 回文检查器
3. js任务队列
```

# 6.链表

```js
  链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成
```

# 6.2 双向链表

在链表中，一个节点只有链向下一个节点的链接；而在双向链表中，链接是双向的：一个链向下一个元素，另一个链向前一个元素，

# 6.3 循环链表

最后一个元素指向下一个元素的指针（tail.next）不是引用 undefined，而是指向第一个元素（head）
`双向循环链表`

# 6.4 有序链表

# 6.5 创建 StackLinkedList 类

# 7 集合

```js
集合是由一组无序且唯一（即不能重复）的项组成的。
set类
constructor() {
  this.items = {};
  }
}
add(element)：向集合添加一个新元素。
delete(element)：从集合移除一个元素。
has(element)：如果元素在集合中，返回 true，否则返回 false。  clear()：移除集合中的所有元素。
size()：返回集合所包含元素的数量。它与数组的 length 属性类似。
values()：返回一个包含集合中所有值（元素）的数组。
```

# 7.3 集合运算

```js
SQL 联接 : 并集 交集 差集 子集
```

# 8 字典和散列表

```js
1. 字典：Map类
2. 散列表：HashMap类
```

# 9 递归

```js
 它从解决问题的各个小部分开始，直到解决最初的大问题
```

# 10. 树

```js
1. 树：一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个节点）以及零个或多个子节点
2. 二叉树：节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。
   二叉搜索树：只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大的值
3. 树的遍历
  1. 中序遍历
  也就是以从最小到最大的顺序访问所有节点。
  2. 先序遍历
  先序遍历是以优先于后代节点的顺序访问每个节点的，从根节点开始，从左边成一个循环
  3. 后序遍历
  后序遍历则是先访问节点的后代节点，再访问节点本身。
4. 搜索树中的值
5. 自平衡树
任意一个节点（不论深度）的左子树和右子树高度最多相差 1
6. 红黑树
自平衡二叉搜索树。
```

# 11 二叉堆和堆排序

```js
1. 二叉堆
  1. 完全二叉树
  2. 堆特性
  所有的节点都大于等于（最大堆）或小于等于（最小堆）每个它的子节点。
2. 堆排序算法
  最大堆和最小堆
```

# 12 图

```js
1. 图是一组由边连接的节点（或顶点）
2. 有向图
3. 无向图
4. 图的遍历
`广度优先搜索`: 队列
`深度优先搜索`: 栈
5. 最短路径算法
   1. Dijkstra 算法（贪心算法）
   2. Floyd-Warshall 算法
```

# 13 排序和搜索算法

```js
1. 冒泡 //O(n^2)
2. 选择排序 //O(n^2)
3. 插入排序法 //
4. 归并排序 //O(nlog(n))
其思想是将原始数组切分成较小的数组，直到每个小数组只有一个位置，接着将小数组归并成较大的数组，直到最后只有一个排序完毕的大数组。
5. 快速排序 //O(nlog(n))
6. 计数排序 //O(n+k)
7. 桶排序
8. 基数排序
```

## 13.2 搜索算法

```js
1. 顺序搜索
2. 二分搜索
3. 内插搜索
二分搜索的一种改造，计算比较值的位置。
```

# 14 算法设计与技巧

```js
1. 分而治之
2. 动态规划
3. 贪心算法
4. 回溯算法
```
