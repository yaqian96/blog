---
title: 学习js数据结构与算法(第3版)(第一部分)
date: 2021-06-29
permalink:
categories: 
  - 学习js数据结构与算法(第3版)
tags: 
  - 学习js数据结构与算法(第3版)
---
# 1. js简介
Apache Cordova ：使用js html css搭建一个应用，并生成apk文件和ipa文件。
## 1.1 JavaScript 数据结构与算法
## 1.2 环境搭建
goole上边安装 web server
步骤：极简插件网站 https://chrome.zzzmh.cn/ 
e'x
## 1.3 JavaScript 基础
      js支持delete运算符
      =======真值truthy与假值falsy======
      undefined    false
      null         false
      布尔值        true 是 true，false 是 false
      数           +0、-0 和 NaN 都是 false，其他都是 true
      字符串        如果字符串是空的（长度是 0）就是 false，其他都是 true（长度大于等于 1）
      对象          true
      ========toNumber================
      undefined     NaN
      null          +0
      布尔值         如果是 true，返回 1；如果是 false，返回+0
      数             数对应的值
      ========toPrimitive================
      如果对象的 valueOf 方法的结果是原始值，返回原始值；如果对象的 toString 方法返回原始值，就返回这个值；其他情况都返回一个错误
# 2. ECMAScript和TypeScript概述
## 2.1 ECMAScript 还是 JavaScript
## 2.2 ECMAScript 2015+的功能
## 2.3 介绍 TypeScript
# 3. 数组
## 3.1 为什么用数组
## 3.2 创建和初始化数组
## 3.3 添加元素
      push()
      unshift()
## 3.4 删除元素
      pop()
      shift()
## 3.5 在任意位置添加或删除元素
     splice()
## 3.6 二维和多维数组
```js
for (let i = 0; i < matrix3x3x3.length; i++) { 
 for (let j = 0; j < matrix3x3x3[i].length; j++) { 
 for (let z = 0; z < matrix3x3x3[i][j].length; z++) { 
  console.log(matrix3x3x3[i][j][z]); 
  } 
 } 
}
```    
## 3.7 JavaScript 的数组方法参考
## 3.8 类型数组
```js
  用于存储单一类型的数据,主要处理二进制数据
  let myArray = new TypedArray (length)
  let length = 5; 
  let int16 = new Int16Array(length); 
  let array16 = []; 
  array16.length = length; 
  for (let i=0; i<length; i++){ 
  int16[i] = i+1; 
  } 
  console.log(int16);
```
## 3.9 TypeScript 中的数组
```js
interface Person {
 name: string; 
 age: number; 
} 
// const friends: {name: string, age: number}[]; 
const friends = [ 
 { name: 'John', age: 30 }, 
 { name: 'Ana', age: 20 }, 
 { name: 'Chris', age: 25 } 
]; 
function comparePerson(a: Person, b: Person) { 
 // comparePerson 函数的内容
}
```
# 4. 栈
## 4.2 栈数据结构
```js
 后进先出
 应用：编程语言的编译器和内存中保存变量、方法调用等，也被用于浏览器历史记录（浏览器的返回按钮）
 // 创建一个基于数组的栈
 class Stack { 
    constructor() { 
    this.items = []; // {1} 
    } 
  }
push(element(s))：添加一个（或几个）新元素到栈顶。
pop()：移除栈顶的元素，同时返回被移除的元素。
peek()：返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）。 
isEmpty()：如果栈里没有任何元素就返回 true，否则返回 false。 
clear()：移除栈里的所有素。
size()：返回栈里的元素个数。该方法和数组的 length 属性很类似。
// 使用Stack类
const stack = new Stack(); 
console.log(stack.isEmpty());
```
## 4.3 创建一个基于 JavaScript 对象的 Stack 类
```js
class Stack { 
  constructor() { 
    this.count = 0; 
    this.items = {}; 
  } 
  push(element) { 
    this.items[this.count] = element; 
    this.count++; 
  }
  size() { 
    return this.count; 
  }
  isEmpty() { 
    return this.count === 0; 
  }
  pop() { 
  if (this.isEmpty()) { // {1} 
    return undefined; 
    } 
    this.count--; // {2} 
    const result = this.items[this.count]; // {3} 
    delete this.items[this.count]; // {4} 
    return result; // {5} 
  } 
  peek() { 
    if (this.isEmpty()) { 
    return undefined; 
    } 
    return this.items[this.count - 1]; 
  }
  clear() { 
    this.items = {}; 
    this.count = 0; 
  }
  toString() { 
    if (this.isEmpty()) { 
    return ''; 
    } 
    let objString = `${this.items[0]}`; // {1} 
    for (let i = 1; i < this.count; i++) { // {2} 
    objString = `${objString},${this.items[i]}`; // {3} 
    } 
    return objString; 
  }
}
```
## 4.4 保护数据结构内部元素
下划线命名私有属性
用 ES2015 的限定作用域 Symbol 实现类
用 ES2015 的 WeakMap 实现类
ECMAScript 类属性提案
## 4.5 用栈解决的问题
```js
1. 从十进制到任意进制
function baseConverter(decNumber, base) { 
 const remStack = new Stack(); 
 const digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; // {6} 
 let number = decNumber; 
 let rem; 
 let baseString = ''; 
 if (!(base >= 2 && base <= 36)) { 
    return ''; 
 } 
 while (number > 0) { 
    rem = Math.floor(number % base); 
    remStack.push(rem); 
    number = Math.floor(number / base); 
 }
 while (!remStack.isEmpty()) { 
    baseString += digits[remStack.pop()]; // {7} 
 } 
 return baseString; 
}
```


# 5. 队列和双端队列
## 5.1 队列数据结构
```js
先进先出，队列在尾部添加新元素，并从顶部移除元素。
enqueue(element(s))：向队列尾部添加一个（或多个）新的项。
dequeue()：移除队列的第一项（即排在队列最前面的项）并返回被移除的元素。
peek()：返回队列中第一个元素——最先被添加，也将是最先被移除的元素。队列不做任何变动（不移除元素，只返回元素信息——与 Stack 类的 peek 方法非常类似）。该方法在其他语言中也可以叫作 front 方法。
isEmpty()：如果队列中不包含任何元素，返回 true，否则返回 false。 
size()：返回队列包含的元素个数，与数组的 length 属性类似。
class Queue { 
 constructor() { 
 this.count = 0; // {1} 
 this.lowestCount = 0; // {2} 
 this.items = {}; // {3} 
  enqueue(element) { 
  this.items[this.count] = element; 
  this.count++; 
  }
  dequeue() { 
  if (this.isEmpty()) { 
  return undefined; 
  } 
  const result = this.items[this.lowestCount]; // {1} 
  delete this.items[this.lowestCount]; // {2} 
  this.lowestCount++; // {3} 
  return result; // {4} 
  }
  peek() { 
  if (this.isEmpty()) { 
  return undefined; 
  } 
  return this.items[this.lowestCount]; 
  }
  isEmpty() { 
    return this.count - this.lowestCount === 0; 
  }
  size() { 
    return this.count - this.lowestCount; 
  }
  clear() { 
    this.items = {}; 
    this.count = 0; 
    this.lowestCount = 0; 
  }
  toString() { 
    if (this.isEmpty()) { 
    return ''; 
    } 
    let objString = `${this.items[this.lowestCount]}`; 
    for (let i = this.lowestCount + 1; i < this.count; i++) { 
    objString = `${objString},${this.items[i]}`; 
    } 
    return objString; 
    }
 } 
}
```
## 5.2 双端队列数据结构
```js
// 允许我们同时从前端和后端添加和移除元素的特殊队列
addFront(element)：该方法在双端队列前端添加新的元素。
addBack(element)：该方法在双端队列后端添加新的元素（实现方法和 Queue 类中的enqueue 方法相同）。
removeFront()：该方法会从双端队列前端移除第一个元素（实现方法和 Queue 类中的dequeue 方法相同）。
removeBack()：该方法会从双端队列后端移除第一个元素（实现方法和 Stack 类中的pop 方法一样）。
peekFront()：该方法返回双端队列前端的第一个元素（实现方法和 Queue 类中的 peek方法一样）。
peekBack()：该方法返回双端队列后端的第一个元素（实现方法和 Stack 类中的 peek方法一样）。
class Deque { 
 constructor() { 
  this.count = 0; 
  this.lowestCount = 0; 
  this.items = {}; 
  } 
}
```
## 5.3 使用队列和双端队列来解决问题