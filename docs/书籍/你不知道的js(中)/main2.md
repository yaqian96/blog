---
title: 你不知道的js(中)(第二部分)
date: 2021-05-14
permalink:
categories: 
  - 你不知道的js(中)
tags: 
  - 你不知道的js(中)
---
# 第二部分 异步和性能
## 第一章 异步：现在与将来
### 1.1 分块的程序
- 将.js文件分成多个块。一个块相当于一个函数。
- 异步控制台
### 1.2 事件循环
- js引擎运行在宿主环境中，通常是web浏览器。
   - 这些环境提供了一种机制来处理程序中多个块的执行，且执行每块时调用 JavaScript 引擎，这种机制被称为事件循环。
- 什么是事件循环？？
  - setTimeout() 并没有将你的回调函数挂在事件循环的队列中。只是定时器执行完之后，环境将回调函数放在事件循环中。
  - eventLoop 事件循环队列中，一个一个地执行
### 1.3 并行线程
- 并行是能够同时发生的事情。例如(多个线程在一个进程中同时运行)
- 与异步的区别
   - 异步是现在与将来的时间间隙。
- js单线程
### 1.4 并发
- 并发是指两个或多个事件链随时间发展交替执行，以至于从更高的层次来看，就像是同时
在运行（尽管在任意时刻只处理一个事件）。
   - 非交互
   - 交互
   - 协作
### 1.5 任务
- 任务队列：指的是每个事件tick的一个队列。
   - 事件循环队列类似一个大圈的执行。任务队列则是每个大圈的小圈。
### 1.6 语句顺序
- 编译器的语句的重排序类似是并发和交互的微型比喻。
## 第二章 回调
### 2.1 continuation
回调函数是js异步的基本单元。
```js
// A 
ajax( "..", function(..){ 
 // C 
} ); 
// B
```
### 2.2 顺序的大脑
- 执行与执行计划
- 嵌套回调与链式回调
   - 嵌套回调导致代码很难区分那个先执行。
### 2.3 信任问题
### 2.4 省点回调
```js
function response(err,data) { 
 // 出错？
 if (err) { 
 console.error( err ); 
 } 
 // 否则认为成功
 else { 
 console.log( data ); 
 } 
} 
ajax( "http://some.url.1", response );
```
## 第三章 Promise
### 3.1 什么是promise
- promise承诺，链式调用，解决回调地狱。
### 3.2 具有then方法的鸭子类型
- instanceof Proimse 检测是否为promise
```js
  if ( 
  p !== null && 
  ( 
  typeof p === "object" || 
  typeof p === "function" 
  ) && 
  typeof p.then === "function" 
  ) { 
  // 假定这是一个thenable! 
  } 
  else { 
  // 不是thenable 
  }
```
### 3.3 promise信任问题
- 调用过早
- 调用过晚
- 回调未调用
- 调用次数过少或过多
- 未能传递参数/环境值
- 吞掉错误和异常
- 是可信任的Promise
### 3.4 链式流
- 多个promise连接到一起表示一系列异步步骤。
   - 每次你对 Promise 调用 then(..)，它都会创建并返回一个新的 Promise，我们可以将其链接起来；
   - 不管从 then(..) 调用的完成回调（第一个参数）返回的值是什么，它都会被自动设置为被链接 Promise（第一点中的）的完成。
- 可以一个从一个步骤到下一个步骤传递消息的消息通道。
- promise的固有特性
  - 调用 Promise 的 then(..) 会自动创建一个新的 Promise 从调用返回。
  - 在完成或拒绝处理函数内部，如果返回一个值或抛出一个异常，新返回的（可链接的）Promise 就相应地决议。
  - 如果完成(fulfill)或拒绝(reject)处理函数返回一个 Promise，它将会被展开，这样一来，不管它的决议(resolve)值是什么，都会成为当前 then(..) 返回的链接 Promise 的决议值。
### 3.5 错误处理
```js
// 一般是 try catch 用于捕获同步的错误。promise的错误一般是在promise.then()中捕获。
// 处理未捕获的错误，一般是在promise最后以一个catch(...)结束。
```
### 3.6 Promise模式
- Promise.all() 所有的都完成，才执行后边的。
- Promise.race() 响应第一个跨过终点的promise,而抛弃其他promise。
- 并发迭代
  - promise上使用map
### 3.7 Promise api
- new Promise()
- Promise.resolve()和Promise.reject()
- then()和catch()
- Promise.all()和promise.race()
### 3.7 Promise局限性
- 顺序错误处理
   - Promise 链中的任何一个步骤都没有显式地处理自身错误
   - 错误会一直向下传递，直到最后一个，所以错误的指明没有那么明显
- 单一值
   - Promise只能传递一个resolve,reject,不能适应值多种情况的时候，可以通过参数解构解决。
- 单决议
- 惯性
- 无法取消的promise(一旦开始，无法停止promise的进程)
   - 单独的 Promise 不应该可取消，但是取消一个可序列是合理的，因为你不会像对待 Promise，那样把序列作为一个单独的不变值来传送。
- Promise性能
## 第四章 生成器
生成器是 ES6 的一个新的函数类型，它并不像普通函数那样总是运行到结束。取而代之的是，生成器可以在运行当中（完全保持其状态）暂停，并且将来再从暂停的地方恢复运行。
   这种交替的暂停和恢复是合作性的而不是抢占式的，这意味着生成器具有独一无二的能力来暂停自身，这是通过关键字 yield 实现的。不过，只有控制生成器的迭代器具有恢复生
成器的能力（通过 next(..)）。
yield/next(..) 这一对不只是一种控制机制，实际上也是一种双向消息传递机制。yield .. 表达式本质上是暂停下来等待某个值，接下来的 next(..) 调用会向被暂停的 yield 表达式传回
一个值（或者是隐式的 undefined）。
  在异步控制流程方面，生成器的关键优点是：生成器内部的代码是以自然的同步 / 顺序方式表达任务的一系列步骤。其技巧在于，我们把可能的异步隐藏在了关键字 yield 的后面，把异步移动到控制生成器的迭代器的代码部分。
### 4.1 打破完整运行
- 在程序运行的过程中，将其暂停，对函数进行执行。使用迭代器
- 输入和输出
   - 生成器函数(输入和输出)
   - 迭代消息传递
- 多个迭代器
   - 多个迭代器之间的值可以相互影响使用。
### 4.2 生成器产生值
- 生产者与迭代器
   - 迭代器之间的值，利用闭包原理产生值
- iterable(可迭代)
   - 含义：包含可以在其值上迭代的迭代器对象
   - Symbol.iterator。调用这个函数时，它会返回一个迭代器。通常每次调用会返回一个全新的迭代器，
- 生成器迭代器
   - 可以把生成器看作一个值的生产者，我们通过迭代器接口的 next() 调用一次提取出一个值。
### 4.3 异步迭代生成器
- yeild 
- 同步错误处理
```js
try { 
 var text = yield foo( 11, 31 ); 
 console.log( text ); 
} 
catch (err) { 
 console.error( err ); 
}
```
### 4.4 生成器+promise
- yield 出来一个 Promise，然后通过这个 Promise 来控制生成器的迭代器。
```js
function foo(x,y) { 
 return request( 
 "http://some.url.1/?x=" + x + "&y=" + y 
 ); 
} 
function *main() { 
 try { 
 var text = yield foo( 11, 31 ); 
 console.log( text ); 
 } 
 catch (err) { 
 console.error( err ); 
 } 
}
var it = main(); 
var p = it.next().value; 
// 等待promise p决议
p.then( 
 function(text){ 
 it.next( text ); 
 }, 
 function(err){ 
 it.throw( err ); 
 } 
);
```
- 生成器中的Promise并发
   - 将promise和生成器结合起来，对数据进行控制。
### 4.5 生成器委托
原因：存在一个生成器中调用另一个生成器
- 使用yield进行委托
目的：代码组织，以达到与普通函数调用的对称。
   - 消息委托
   - 异步委托
   - 递归委托
### 4.6 生成器并发
- 采用数组的方式进行数据的转移。
### 4.7 形实转换程序
- thunk
### 4.8 ES6之前生成器
- 采用转换将其进行执行
## 第五章 程序性能
### 5.1 Web Worker
- 像你的浏览器这样的环境，很容易提供多个 JavaScript 引擎实例，各自运行在自己的线程上，这样你可以在每个线程上运行不同的程序。程序中每一个这样的独立的多线程部分被称为一个（Web）Worker。这种类型的并行化被称为任务并行，因为其重点在于把程序划分为多个块来并发运行。
1. Worker w1 对象是一个事件侦听者和触发者，可以通过订阅它来获得这个 Worker 发出的事件以及发送事件给这个 Worker。
2. worker环境
   - 无法访问主程序的任何资源，但是可以访问几个重要的全局变量和功能本地副本，包括 navigator、location、JSON 和applicationCache。
3. 应用场景
   • 处理密集型数学计算
   • 大数据集排序
   • 数据处理（压缩、音频分析、图像处理等）
   • 高流量网络通信
4. 数据传递
   - 结构化克隆算法
   - Transferable 对象
5. 共享Worker
   - SharedWorker
### 5.2 SIMD
- 单指令多数据（SIMD）是一种数据并行（data parallelism）方式，并行处理数据的多个位。
- 原理：现代 CPU 通过数字“向量”（特定类型的数组），以及可以在所有这些数字上并行操作的指令，来提供 SIMD 功能。这是利用低级指令级并行的底层运算
### 5.3 asm.js
- 这个标签是指 JavaScript 语言中可以高度优化的一个子集。通过小心避免某些难以优化的机制和模式（垃圾收集、类型强制转换，等等），asm.js 风格的代码可以被 JavaScript 引擎识别并进行特别激进的底层优化。
- stdlib
## 第六章 性能测试与调优
### 6.1 性能测试
- Benchmark.js
   - Benchmark.js 当然可以用在浏览器中测试 JavaScript（参见 6.3 节），它也可以在非浏览器环境中运行（Node.js 等）
### 6.2 环境为王
- 引擎优化
### 6.3 jsPerf.com
- 它使用我们前面介绍的 Benchmark.js 库来运行统计上精确可靠的测试，并把测试结果放在一个公开可得的 URL 上，你可以把这个 URL 转发给别人。每次测试运行的时候，测试结果就会被收集并持久化，累积的测试结果会被图形化，并展示到一个页面上以供查看。
- 完整性检查
### 6.4 写好测试
### 6.5 微性能
- 不是所有的引擎都类似
### 6.6 尾调用优化
- TCO 尾调用就是一个出现在另一个函数“结尾”处的函数调用。这个调用结束后就没有其余的事情可做了。
```js
function factorial(n) { 
 function fact(n,res) { 
 if (n < 2) return res; 
 return fact( n - 1, n * res ); 
 } 
 return fact( n, 1 ); 
} 
factorial( 5 ); // 120
```
调用一个新的函数需要额外的一块预留内存来管理调用栈，成为`栈帧`
使用尾部调用，则可以重用所在函数的`栈帧`，速度快，更节省性能。