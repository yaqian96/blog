---
title: js高级程序设计(4版3)
date: 2021-06-09
permalink:
categories: 
  - js高级程序设计
tags: 
  - js高级程序设计

---

# 11 期约与异步函数

## 11.1 异步编程

### 11.1.1 同步与异步

    同步行为对应内存中顺序执行的处理器指令，异步有回调地狱

### 11.1.2 以往的异步编程模式

    异步返回值：回调函数

## 11.2 期约（Promise）

      promise
      执行函数是同步执行的

```js
function delayedResolve(str) {
  return new Promise((resolve, reject) => {
    console.log(str);
    setTimeout(resolve, 1000);
  });
}
delayedResolve("p1 executor")
  .then(() => delayedResolve("p2 executor"))
  .then(() => delayedResolve("p3 executor"))
  .then(() => delayedResolve("p4 executor"));
// p1 executor（1 秒后）
// p2 executor（2 秒后）
// p3 executor（3 秒后）
// p4 executor（4 秒后）
// 返回的格式是二叉树的表现形式
```

## 11.3 异步函数

```js
//async 关键字用于声明异步函数。这个关键字可以用在函数声明、函数表达式、箭头函数和方法上
async function foo() {
 console.log(1);
 return 3;
}
// 给返回的期约添加一个解决处理程序
foo().then(console.log);
console.log(2);
// 1
// 2
// 3
// 返回一个原始值
async function foo() {
 return 'foo';
}
foo().then(console.log);
// foo
// 返回一个没有实现 thenable 接口的对象
async function bar() {
 return ['bar'];
}
bar().then(console.log);
// ['bar']
// 返回一个实现了 thenable 接口的非期约对象
async function baz() {
 const thenable = {
 then(callback) { callback('baz'); }
 };
 return thenable;
}
baz().then(console.log);
// baz
async function qux() {
 return Promise.resolve('qux');
}
qux().then(console.log);
// qux
与在期约处理程序中一样，在异步函数中抛出错误会返回拒绝的期约：
async function foo() {
 console.log(1);
 throw 3;
}
// 给返回的期约添加一个拒绝处理程序
foo().catch(console.log);
console.log(2);
// 1
// 2
// 3
-----------------------------
await 主要针对不会马上立马完成的任务。使用 await 关键字可以暂停异步函数代码的执行，等待期约解决
await 关键字必须在异步函数中使用，
------------------------------
异步函数策略
// 实现sleep()
 return new Promise((resolve) => setTimeout(resolve, delay));
}
async function foo() {
 const t0 = Date.now();
 await sleep(1500); // 暂停约 1500 毫秒
 console.log(Date.now() - t0);
}
foo();
// 1502
// 平行执行
// 串行执行期约
// 栈追踪与内存管理
当前js引擎栈内存中函数调用之间的嵌套关系
```

## 11.4 小结

     异步函数是将期约应用于 JavaScript 函数的结果。异步函数可以暂停执行，而不阻塞主线程。无论是编写基于期约的代码，还是组织串行或平行执行的异步代码，使用异步函数都非常得心应手。异步函数可以说是现代 JavaScript 工具箱中最重要的工具之一。

# 12 BOM

## 12.1 window 对象

     双层身份，一个是es的Global对象，另一个是浏览器窗口的js接口。

```js
// 12.1.1 Global 作用域
var age = 29;
var sayAge = () => alert(this.age);
alert(window.age); // 29
// 12.1.2 窗口关系
top 对象始终指向最上层（最外层）窗口，即浏览器窗口本身。而 parent 对象则始终指向当前窗口的父窗口。
// 12.1.3 窗口位置与像素比
window.devicePixelRatio 表示物理像素与逻辑像素之间的缩放系数。
// 12.1.4 窗口大小
document.documentElement.clientWidth 和 document.documentElement.clientHeight返回页面视口的宽度和高度。
innerWidth、innerHeight、outerWidth 和 outerHeight
`移动浏览器`中，document.documentElement.clientWidth 和 document.documentElement.clientHeight 返回的布局视口的大小，即渲染页面的实际大小。
// 12.1.5 视口位置
window.pageXoffset/window.scrollX 和 window.pageYoffset/window.scrollY。
// 12.1.6 导航与打开新窗口
window.open()方法可以用于导航到指定 URL，也可以用于打开新浏览器窗口。接收4个参数。
window对象有一个opener属性，指向打开它的窗口。
`窗口不会跟踪记录自己打开的新窗口，因此开发者需要自己记录。`
`浏览器会在用户操作下才允许创建弹窗。在网页加载过程中调用 window.open()没有效果，`
// 弹窗屏蔽程序，用来判断弹出框是否被关闭
let wroxWin = window.open("http://www.wrox.com", "_blank");
if (wroxWin == null){
 alert("The popup was blocked!");
}
// 12.1.7 定时器
setTimeout() setInterval()
// 12.1.8 系统对话框
alert()、confirm()和 prompt()方法
```

## 12.2 location 对象

```js
提供了当前窗口中加载文档的信息，以及通常的导航功能
// 查询字符串
window.location.search()
// 操作地址
location.assign("http://www.wrox.com");
location.replace()  //重新加载后没有历史数据，不能返回到上一页。
location.reload(); // 重新加载，可能是从缓存加载
location.reload(true); // 重新加载，从服务器加载
```
## 12.3 navigator 对象
```js
// 检测浏览器中是否安装插件
let hasPlugin = function(name) {
  name = name.toLowerCase();
  for (let plugin of window.navigator.plugins) {
    if (plugin.name.toLowerCase().indexOf(name) > -1) {
      return true;
    }
  }
  return false;
};
function hasIEPlugin(name) { 
 try { 
 new ActiveXObject(name); 
 return true; 
 } catch (ex) { 
 return false; 
 } 
}
// 12.3.2 注册处理程序
navigator.registerProtocolHandler("mailto", 
 "http://www.somemailclient.com?cmd=%s", 
 "Some Mail Client");
```
## 12.4 screen 对象
是浏览器窗口外面的客户端显示器的信息，比如像素宽度和像素高度
## 12.5 history 对象
```js
//history 对象表示当前窗口首次使用以来用户的导航历史记录
// 12.5.1 导航
history.go(-1);
history.back(); 
history.forward(); // 前进一页
history.length    //历史记录的条目
// 12.5.2 历史状态管理
history.pushState(stateObject, "My title", "baz.html");
popstate()
history.replaceState({newFoo: "newBar"}, "New title");
```
## 12.6 小结

# 13 客户端检测
## 13.1 能力检测（特性检测）
```js
if (object.propertyInQuestion) {
 // 使用 object.propertyInQuestion
} 
// 安全能力检测 是检测能力是否存在的同时，验证其是否能够展现出预期的行为
// 基于能力检测进行浏览器分析
```
## 13.2 用户代理检测
```js
navigator.userAgent
```
## 13.3 软件与硬件检测
```js
1. navigator.oscpu
navigator.oscpu 属性是一个字符串，通常对应用户代理字符串中操作系统/系统架构相关信息。
2. navigator.vendor
navigator.vendor 属性是一个字符串，通常包含浏览器开发商信息。
3. navigator.platform
navigator.platform 属性是一个字符串，通常表示浏览器所在的操作系统。
4. screen.colorDepth 和 screen.pixelDepth
5. screen.orientation
//  浏览器元数据
1. Geolocation API
```
# 14 DOM
## 14.1 节点层级
```js
// 12种节点层级 nodeType
// nodeName  元素的标签名
// nodeValue 对于元素为null
每个节点都有一个 childNodes 属性，其中包含一个 NodeList 的实例。
每个节点都有一个 parentNode 属性，指向其 DOM 树中的父元素。
// previousSibling nextSibling
// firstChild 第一个子节点
// lastChild 最后一个子节点
-----------------------
ownerDocument 属性是一个指向代表整个文档的文档节点的指针。
```
```js
// 操作节点
1. appendChild()，用于在 childNodes 列表末尾添加节点。
2. insertBefore(要插入的节点，参照节点)，将节点插入到指定的位置。
3. replaceChild()，将会删除已有的节点，替换掉
4. removeChild(), 移除节点
5. cloneNode()， 复制节点 ，可进行深复制（复制节点和整个子Dom树）
6. normalize() 处理文档子树中的文本节点。
```
### 14.1.2 Document类型
```js
// 文档节点的类型（只读的）
 nodeType 9
 nodeName #document
//  documentElement    -->   始终指向 HTML 页面中的<html>元素
// body   --> 直接指向<body>元素
// document.doctype --> 获取对<!doctype>的引用
//  document.title  -->获取浏览器或者标签页的标题栏
// 取得完整的 URL 
let url = document.URL; 
// 取得域名
let domain = document.domain; 
// 取得来源
let referrer = document.referrer;
-----------------------------
// 定位元素
getElementById()
getElementsByTagName()
getElementsByName() 
document.implementation 属性是一个对象，其中提供了与浏览器 DOM 实现相关的信息和能力。
---------------------------
// 文档写入
// 在页面加载期间向其中动态添加内容和加载完成之后
write()  简单地写入文本
writeln() 还会在字符串末尾追加一个换行符（\n）。
```
### 14.1.3 Element 类型
```js
<div id="myDiv"></div> 
let div = document.getElementById("myDiv"); 
alert(div.tagName); // "DIV" 
alert(div.tagName == div.nodeName); // true
---------HTML元素--------------
//  id title lang dir className
---------取得属性--------------
//属性名不区分大小写
let div = document.getElementById("myDiv"); 
alert(div.getAttribute("id")); // "myDiv" 
alert(div.getAttribute("class")); // "bd" 
alert(div.getAttribute("title")); // "Body text" 
alert(div.getAttribute("lang")); // "en" 
alert(div.getAttribute("dir")); // "ltr"
setAttribute() //设置属性名和属性值
removeAttribute() //移除属性
attributes
---------创建元素-----------
createElement()
```
### 14.1.4 Text 类型
```js
// nodeType为3
appendData()
createTextNode()可以用来创建新文本节点
normalize()，可以合并相邻的文本节点
splitText() 拆分文本节点
```
### 14.1.5 Comment 类型
```js
//nodeType 8
createComment() 方法创建注释节点
```
### 14.1.6 CDATASection 类型
     XML 中特有的 CDATA 区块
### 14.1.7 DocumentType 类型
### 14.1.8 DocumentFragment 类型(文档片段)
### 14.1.9 Attr 类型
     document.createAttribute()
## 14.2 DOM编程
### 14.2.1 动态脚本
### 14.2.2 动态样式
### 14.2.3 操作表格
### 14.2.4 使用 NodeList
      nodeList是基于DOM文档的实时查询
## 14.3 MutationObserver 接口 ------vue中的obeserver???
      可以观察整个文档、DOM 树的一部分，或某个元素,可以在 DOM 被修改时异步执行回调
```js
let observer = new MutationObserver(() => console.log('<body> attributes changed')); 
observer.observe(document.body, { attributes: true }); 
document.body.className = 'foo'; 
console.log('Changed body class'); 
// Changed body class 
// <body> attributes changed
-----------mutationRecords------------
let observer = new MutationObserver( 
 (mutationRecords) => console.log(mutationRecords));
observer.observe(document.body, { attributes: true }); 
document.body.setAttribute('foo', 'bar'); 
// [ 
// { 
// addedNodes: NodeList [],
// attributeName: "foo", 
// attributeNamespace: null, 
// nextSibling: null, 
// oldValue: null, 
// previousSibling: null 
// removedNodes: NodeList [], 
// target: body 
// type: "attributes" 
// } 
// ]
-------------------disconnect() 终止执行回调---------
-------------------复用MutationObserver-----------
------------------MutationObserverInit 与观察范围---

```
# 15 DOM 扩展
## 15.1 Selectors API
```js
querySelector() //可在Document和Element上使用
querySelectorAll() //返回所有的匹配节点
matches()方法  //接收一个 CSS 选择符参数
```
## 15.2 元素遍历
```js
let parentElement = document.getElementById('parent'); 
let currentChildNode = parentElement.firstChild; 
// 没有子元素，firstChild 返回 null，跳过循环
while (currentChildNode) { 
 if (currentChildNode.nodeType === 1) { 
 // 如果有元素节点，则做相应处理
 processChild(currentChildNode); 
 } 
 if (currentChildNode === parentElement.lastChild) { 
 break; 
 } 
 currentChildNode = currentChildNode.nextSibling; 
}
```
## 15.3 HTML5
```js
1. getElementsByClassName()
classList属性  add() contains() remove() toggle()
2. 焦点管理
document.activeElement //设置focus元素
document.hasFocus() // 该方法返回布尔值，表示文档是否拥有焦点
3. HTMLDocument 扩展
 readyState // loading 正在加载 complete表示文档加载完成
 compatMode 属性 // 检查是标准（CSS1Compat）或者混杂模式（BackCompat）
 document.head 属性 // 指向文档的<head>元素。
4. 字符集属性 characterSet
5. 自定义数据属性
<div id="myDiv" data-appId="12345" data-myname="Nicholas"></div>
if (div.dataset.myname){ 
 console.log(`Hello, ${div.dataset.myname}`); 
}
6. 插入标记
innerHTML 
outerHTML 属性 // 会返回调用它的元素（及所有后代元素）的 HTML 字符串
insertAdjacentHTML()与 insertAdjacentText()
7 scrollIntoView()
// 以滚动浏览器窗口或容器元素以便包含元素进入视口
``` 
## 15.4 专有扩展
```js
children 
contains()
innerText //插入文本
outerText
-------滚动------
scrollIntoViewIfNeeded()
scrollIntoViewIfNeeded(alingCenter)
```
# 16 DOM2 和 DOM3
## 16.1 DOM 的演进
```js
// DocumentType 新增了 3 个属性：publicId、systemId 和 internalSubset。
// Document 的变化   importNode()
// Node 的变化  isSameNode()和 isEqualNode()
```
## 16.2 样式
```js
// style
cssText //style 属性中的 CSS 代码
cssText，//包含 style 属性中的 CSS 代码。
length，//应用给元素的 CSS 属性数量。
parentRule，//表示 CSS 信息的 CSSRule 对象（下一节会讨论 CSSRule 类型）。
getPropertyCSSValue(propertyName)，//返回包含 CSS 属性 propertyName 值的 CSSValue对象（已废弃）。
getPropertyPriority(propertyName)// CSS 属性 propertyName 使用了!important则返回"important"，否则返回空字符串。
getPropertyValue(propertyName)，//返回属性 propertyName 的字符串值。
item(index)，//返回索引为 index 的 CSS 属性名。
removeProperty(propertyName)，//从样式中删除 CSS 属性 propertyName。 
setProperty(propertyName, value, priority)，//设置 CSS 属性 propertyName 的值为value，priority 是"important"或空字符串。
//计算属性
document.defaultView.getComputedStyle
// 操作样式表
disabled
href
media
ownerNode
title
type
// css规则----@import、@font-face、@page、@charset
CSSRule
-------------------元素尺寸---------------
// 偏移尺寸
// 客户端尺寸
// 滚动尺寸
// 确定元素尺寸 getBoundingClientRect()
```
## 16.3 遍历
1. NodeIterator()
2. TreeWalker()
## 16.4 范围
# 17 事件
## 17.1 事件流
```js
//描述了页面接收事件的顺序
// 冒泡
// 捕获（拦截）
// 顺序：事件捕获、到达目标和事件冒泡
```
## 17.2 事件处理程序
```js
addEventListener()
removeEventListener() //true 表示在捕获阶段调用事件处理程序，false（默认值）表示在冒泡阶段调用事件处理程序。
attachEvent()和 detachEvent()。//IE中使用
-------------------通用方法--------------------
var EventUtil = { 
 addHandler: function(element, type, handler) { 
 if (element.addEventListener) { 
 element.addEventListener(type, handler, false); 
 } else if (element.attachEvent) { 
 element.attachEvent("on" + type, handler); 
 } else { 
 element["on" + type] = handler; 
 } 
 }, 
 removeHandler: function(element, type, handler) { 
 if (element.removeEventListener) { 
 element.removeEventListener(type, handler, false); 
 } else if (element.detachEvent) { 
 element.detachEvent("on" + type, handler); 
 } else { 
 element["on" + type] = null; 
 } 
 } 
};
```
## 17.3 事件对象
```js
 event 对象
 //preventDefault() 方法用于阻止特定事件的默认动作
 //stopPropagation()  立即阻止事件流在 DOM 结构中传播，取消后续的事件捕获或冒泡
 ----IE----
 // returnValue==false 阻止特定事件的默认动作
 //  cancelBubble=true  只会取消冒泡
 ----跨浏览器事件对象---
```
## 17.4 事件类型
```js
html5事件
1. contextmenu 右键显示上下文菜单
2. beforeunload 事件  //是给开发者提供阻止页面被卸载的机会
window.addEventListener("beforeunload", (event) => { 
 let message = "I'm really going to miss you if you go."; 
 event.returnValue = message; 
 return message; 
});
3. DOMContentLoaded 事件 //DOM 树构建完成后立即触发
4. readystatechange 事件 //提供文档或元素加载状态的信息,但是不稳定
5. pageshow 与 pagehide 事件
(function() { 
 let showCount = 0; 
 window.addEventListener("load", () => { 
 console.log("Load fired"); 
 }); 
 window.addEventListener("pageshow", () => { 
 showCount++; 
 console.log(`Show has been fired ${showCount} times.`); 
 }); 
})();
6. hasChange事件 //用于在 URL 散列值（URL 最后#后面的部分）发生变化时通知开发者。
window.addEventListener("hashchange", (event) => { 
 console.log(`Current hash: ${location.hash}`); 
});
-----------设备事件---------------
1. orientationchange 事件
2. deviceorientation  //deviceorientation 事件只反映设备在空间中的朝向，
3. devicemotion //这个事件用于提示设备实际上在移动，而不仅仅是改变了朝向。
---------触摸及手势事件---------
1. touchstart
2. touchmove
3. touchend
4. touchcancel
1. gesturestart
2. gesturechange
3. gestureend
```
## 17.5 内存与性能
```js
1. 事件委托
2. 删除事件处理程序
// 在dom元素删除之前，删除掉事件处理程序
// 页面卸载之前处理掉
```
## 17.6 模拟事件
```js
1. DOM 事件模拟
createEvent()
2. IE事件模拟
createEventObject()
```
# 18 动画与 Canvas 图形
## 18.1 requestAnimationFrame
```js
function updateProgress() { 
 var div = document.getElementById("status"); 
 div.style.width = (parseInt(div.style.width, 10) + 5) + "%"; 
 if (div.style.left != "100%") { 
 requestAnimationFrame(updateProgress); 
 } 
} 
requestAnimationFrame(updateProgress);
cancelAnimationFrame()// 取消重绘任务
-----通过requestAnimationFrame 节流------
let enabled = true; 
function expensiveOperation() { 
 console.log('Invoked at', Date.now()); 
} 
window.addEventListener('scroll', () => { 
 if (enabled) { 
 enabled = false; 
 window.requestAnimationFrame(expensiveOperation); 
 window.setTimeout(() => enabled = true, 50); 
 } 
});
```
## 18.2 基本的画布功能
## 18.3 2D 绘图上下文
## 18.4 WebGL

# 19 表单脚本
## 19.1 表单基础
```js
document.forms //获取页面上所有的表单元素
// 提交表单
<!-- 通用提交按钮 --> 
<input type="submit" value="Submit Form"> 
<!-- 自定义提交按钮 --> 
<button type="submit">Submit Form</button> 
<!-- 图片按钮 --> 
<input type="image" src="graphic.gif">
---------重置表单----------
<!-- 通用重置按钮 --> 
<input type="reset" value="Reset Form"> 
<!-- 自定义重置按钮 --> 
<button type="reset">Reset Form</button>
---------表单字段--------
elements 集合
focus()和 blur()
autofocus 属性，支持的浏览器会自动为带有该属性的元素设置焦点
事件：blur() change() focus()
```
## 19.2 文本框编程
```js
<input type="text" size="25" maxlength="50" value="initial value">
<textarea rows="25" cols="5">initial value</textarea>
--------------------选择文本----------------
select()
textbox.addEventListener("focus", (event) => { 
  // 一获取焦点就选中所有的焦点
 event.target.select(); 
});
selectionStart  selectionEnd //文本选区的起点和终点
function getSelectedText(textbox){ 
 return textbox.value.substring(textbox.selectionStart, 
 textbox.selectionEnd); 
//  文本框选中的所有文本
}
------------部分选中文本-----------
textbox.value = "Hello world!" 
// 选择所有文本
textbox.setSelectionRange(0, textbox.value.length); // "Hello world!" 
// 选择前 3 个字符
textbox.setSelectionRange(0, 3); // "Hel"
-----------------输入过滤-----------
1. 屏蔽字符 
textbox.addEventListener("keypress", (event) => { 
 if (!/\d/.test(String.fromCharCode(event.charCode)) && 
 event.charCode > 9 && 
 !event.ctrlKey){ 
 event.preventDefault(); 
 }
});
2. 处理剪贴板
// 事件 beforecopy copy beforecut cut beforepaste paste
clipboardData对象
3. 自动切换
<input type="text" name="tel1" id="txtTel1" maxlength="3"> 
<input type="text" name="tel2" id="txtTel2" maxlength="3"> 
<input type="text" name="tel3" id="txtTel3" maxlength="4">
function tabForward(event){ 
 let target = event.target; 
 if (target.value.length == target.maxLength){ 
 let form = target.form; 
 for (let i = 0, len = form.elements.length; i < len; i++) { 
 if (form.elements[i] == target) { 
 if (form.elements[i+1]) { 
 form.elements[i+1].focus(); 
  } 
  return; 
    } 
   } 
  } 
}
4. 必填字段
required 
输入类型 email url number range datetime datetime-local date month week
stepUp()和 stepDown() //加减
pattern   //输入模式
checkValidity() //检测有效性
novalidate //禁用验证
```
## 19.3 选择框编程
```js
<select name="location" id="selLocation"> 
 <option value="Sunnyvale, CA">Sunnyvale</option> 
 <option value="Los Angeles, CA">Los Angeles</option> 
 <option value="Mountain View, CA">Mountain View</option> 
 <option value="">China</option> 
 <option>Australia</option> 
</select>
let text = selectbox.options[0].text; // 选项文本
let value = selectbox.options[0].value; // 选项值
// 选项处理 
只允许选择一个 selectedIndex
// 添加选项，通过动态添加节点和add()
// 移除选项 ，removeChild()和选择框的remove()
```
## 19.4 表单序列化
## 19.5 富文本编辑
```js
contenteditable属性 //元素可编辑
execCommand() 执行指令，实现大多数格式化任务
getSelection()方法，可以获得富文本编辑器的选区
//通过表单提交富文本
```
# 20 js API
## 20.1 Atomics 与 SharedArrayBuffer
```js
// 通过强制同一时刻只能对缓冲区执行一个操作，可以让多个上下文安全地读写一个SharedArrayBuffer。
```
## 20.2 跨上下文消息
```js
----------------postMessage()-------------
let iframeWindow = document.getElementById("myframe").contentWindow; 
iframeWindow.postMessage("A secret", "http://www.wrox.com");
window.addEventListener("message", (event) => { 
 // 确保来自预期发送者
 if (event.origin == "http://www.wrox.com") { 
 // 对数据进行一些处理
 processMessage(event.data); 
 // 可选：向来源窗口发送一条消息
 event.source.postMessage("Received!", "http://p2p.wrox.com"); 
 } 
});
```
## 20.3 Encoding API
```js
//字符串转换为定型数组二进制格式
TextEncoder()
TextDecoder()
TextEncoderStream() //流编码
TextDecoderStream()
```
## 20.4 File API 与 Blob API
```js
FileReader //从文件中读取数据，异步文件读取机制，类似XMLHttpRequest
FileReaderSync //FileReader 的同步版本
---------对象URL与Blob-----------
`对象URL`:引用存储在 File 或 Blob 中数据的 URL
```
## 20.5 媒体元素
```js
<!-- 嵌入视频 --> 
<video src="conference.mpg" id="myVideo">Video player not available.</video> 
<!-- 嵌入音频 --> 
<audio src="song.mp3" id="myAudio">Audio player not available.</audio>
```
## 20.7 Notifications API
## 20.8 Page Visibility API
