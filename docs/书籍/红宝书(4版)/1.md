---
title: js高级程序设计(4版1)
date: 2021-05-22
permalink:
categories:
  - js高级程序设计
tags:
  - js高级程序设计
---

# 第 1 章 什么是 javascript

## 1.1 简短的历史回顾

- LiveScript(曾用名)，1995 年开始
- 1998 年-ECMAScript 标准

## 1.2 js 的实现

- 三部分：核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）

1. ECMAScript，即 ECMA-262 定义的语言。不局限于 web 浏览器。Web 浏览器只是 ECMAScript 实现可能存在的一种宿主环境。
   - 语法
   - 类型
   - 语句
   - 关键字
   - 保留字
   - 操作符
   - 全局对象

- 第 10 版（ES10、ES2019）
- 浏览器对 ECMAScript 的支持

2. DOM(文档对象模型)
   - DOM 的级别
   - Web 浏览器对 DOM 的支持情况
3. BOM(浏览器对象模型)
   - 用于支持访问和操作浏览器的窗口,主要针对浏览器窗口和子窗口。

## 1.3 JavaScript 版本

---

小结：JavaScript 的这三个部分得到了五大 Web 浏览器（IE、Firefox、Chrome、Safari 和 Opera）不同程度的支持。所有浏览器基本上对 ES5（ECMAScript 5）提供了完善的支持，而对 ES6（ECMAScript 6）和 ES7（ECMAScript 7）的支持度也在不断提升。这些浏览器对 DOM 的支持各不相同，但对 Level 3 的支持日益趋于规范。HTML5 中收录的 BOM 会因浏览器而异，不过开发者仍然可以假定存在很大一部分公共特性。

---

# 第 2 章 HTML 中的 JavaScript

- 通过脚本的方式，将 js 插入到 html

## 2.1 `<script>`元素

    async:表示应该立即开始下载脚本。
    charset：使用 src 属性指定的代码字符集。
    crossorigin：配置相关请求的CORS（跨源资源共享）设置
    defer：表示脚本可以延迟到文档完全被解析和显示之后再执行。
    integrity：允许比对接收到的资源和指定的加密签名以验证子资源完整性
    src: 指向外部文件的地址
    type: text/javascript es6的module。

使用行内元素的时候，要注意代码中不能出现字符串`</script>`。会报错。

### 2.1.1 标签位置

    -放在body里面。

### 2.1.2 推迟执行脚本 defer,defer 只对外部文件才有效。

### 2.1.3 异步执行脚本 async

    并不保证能按照它们出现的次序执行,但是会在页面load 事件前执行

### 2.1.4 动态加载脚本。创建`<script>`元素，进行添加到 DOM.

### 2.1.5 XHTML 中的变化

    是将 HTML 作为 XML的应用重新包装的结果
    规则：在 XHTML 中使用 JavaScript 必须指定 type 属性且值为text/javascript

### 2.1.6 废弃的语法

## 2.2 行内代码与外部文件

外部文件：可维护性、缓存、适应未来

## 2.3 文档模式

混杂模式、标准模式、标准准模式

## 2.4 `<noscript>`元素

内容：浏览器不支持脚本、浏览器对脚本的支持被关闭

---

JavaScript 是通过`<script>`元素插入到 HTML 页面中的。这个元素可用于把 JavaScript 代码嵌入到 HTML 页面中，跟其他标记混合在一起，也可用于引入保存在外部文件中的 JavaScript。本章的重点可以总结如下。

- 要包含外部 JavaScript 文件，必须将 src 属性设置为要包含文件的 URL。文件可以跟网页在同一台服务器上，也可以位于完全不同的域。
- 所有`<script>`元素会依照它们在网页中出现的次序被解释。在不使用 defer 和 async 属性的情况下，包含在`<script>`元素中的代码必须严格按次序解释。
- 对不推迟执行的脚本，浏览器必须解释完位于`<script>`元素中的代码，然后才能继续渲染页面的剩余部分。为此，通常应该把`<script>`元素放到页面末尾，介于主内容之后及`</body>`标签之前。
- 可以使用 defer 属性把脚本推迟到文档渲染完毕后再执行。推迟的脚本原则上按照它们被列出的次序执行。
- 可以使用 async 属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行。
- 通过使用`<noscript>`元素，可以指定在浏览器不支持脚本时显示的内容。如果浏览器支持并启用脚本，则`<noscript>`元素中的任何内容都不会被渲染

---

# 第 3 章 语言基础

## 3.1 语法

### 3.1.1 区分大小写

### 3.1.2 标识符

     标识符，就是变量、函数、属性或函数参数的名称。

### 3.1.3 注释

### 3.1.4 严格模式

     "use strict";

### 3.1.5 语句

## 3.2 关键字与保留字

## 3.3 变量

`var let 区别`：let 声明的范围是块作用域，而 var 声明的范围是函数作用域。块作用域是函数作用域的子集 <br/>
`全局变量和局部变量`：全局变量在函数外部或者函数内部不使用 var，局部变量在函数内部。 <br/>
`暂时性死区`：使用未声明的变量，let 之前 <br/>
`条件声明`：在使用 var 声明变量时，由于声明会被提升，JavaScript 引擎会自动将多余的声明在作用域顶部合并为一个声明。因为 let 的作用域是块，所以不可能检查前面是否已经使用 let 声明过同名变量，同时也就不可能在没有声明的情况下声明它。 <br/>
`const声明`：是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。声明是块作用域。`如果 const 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 const 的限制。`

## 3.4 数据类型

     *** 简单类型
     Undefined   --->(typeof) undefined
     Null        --->(typeof) object
     Boolean     --->(typeof) boolean
     Number      --->(typeof) number
     String      --->(typeof) string
     Symbol      --->(typeof) symbol
                 --->function (typeof) symbol function
     ***
     *** 复杂类型
     Object
     ***

Null 类型：空对象指针(`假值`)<br/>
Undefined 类型: 初始化但未定义(`假值`)<br/>
Boolean 类型：值有 true 和 false<br/>

---

Number 类型：十进制、八进制、十六进制。

1. `八进制`在严格模式下，是无效的，会导致 js 引擎抛出语法错误。
2. 浮点数。
3. 值的范围
   Number.MIN_VALUE--------5e-324
   Number.MAX_VALUE--------1.797 693 134 862 315 7e+308
   超过范围则 Infinity
4. NaN(不是数值)
   isNaN(pars),判断参数 pars 是否为一个数值。
5. 数值转换
   ```js
   Number(); //用于任何类型转换成数值
   //用于将字符串转换成数值以下两个
   parseInt();
   //整数，parseInt()函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。
   //parseInt()函数也能识别不同的整数格式（十进制、八进制、十六进制）
   //可以传第二个参数，用于指定底数(进制数)
   parseFloat();
   //如果第一个字符不是数值字符、加号或减号，parseInt()立即返回 NaN。
   //只识别十进制格式的数字
   ```

---

String 类型

1. 字符字面量
2. 字符串的特点:不可变的。
3. 转换为字符串
   toString() //toString()方法可见于数值、布尔值、对象和字符串值。

```js
let num = 10;
console.log(num.toString()); // "10"
console.log(num.toString(2)); // "1010"
null.toString(); //'null'
undefined.toString(); //'undefined'
true.toString(); //'true'
```

4. 模板字符串和字符串插值
5. 模板字面量标签函数

```js
通过前缀到模板自变量来应用自定义行为;
```

6. 原始字符串
   使用模板字面量也可以直接获取原始的模板字面量内容。String.raw 标签函数

---

Symbol 类型
确保对象的属性使用唯一标识符，不会发生属性冲突的危险

1. 符号的基本使用

```js
let genericSymbol = Symbol();
console.log(genericSymbol); // Symbol()
let mySymbol = new Symbol(); // TypeError: Symbol is not a constructor
```

2. 使用全局符号注册表
   如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册
   表中创建并重用符号。<br/>
   Symbol.for() <br/>
   Symbol.keyFor()来查询全局注册表,这个方法接收符号，返回该全局符号对应的字符串键。
3. 使用符号作为属性
   凡是可以使用字符串或数值作为属性的地方，都可以使用符号。<br/>
   Object.getOwnPropertySymbols()返回对象实例的符号属性数组 <br/>
4. 常用的内置符号
   是重新定义它们，从而改变原生结构的行为<br/>
   所有内置符号属性都是不可写、不可枚举、不可配置的。
   for-of
5. Symbol.asyncIterator
6. Symbol.hasInstance
7. Symbol.isConcatSpreadable
8. Symbol.iterator
9. `Symbol.match` `Symbol.replace` `Symbol.search` `Symbol.species` `Symbol.split` `Symbol.toPrimitive` `Symbol.toStringTag` `Symbol.unscopables`
   Symbol.match 为键的函数来对正则表达式求值

---

Object 类型

---

操作符

1. 一元操作符

```js
//++和--
let s1 = "2";
let s2 = "z";
let b = false;
let f = 1.1;
let o = {
valueOf() {
return -1;
}
};
s1++; // 值变成数值 3
s2++; // 值变成 NaN
b++; // 值变成数值 1
f--; // 值变成 0.10000000000000009（因为浮点数不精确）
<!-- 一元的加和减 -->
  let s1 = "01";
  let s2 = "1.1";
  let s3 = "z";
  let b = false;
  let f = 1.1;
  let o = {
  valueOf() {
    return -1;
    }
  };
  s1 = +s1; // 值变成数值 1
  s2 = +s2; // 值变成数值 1.1
  s3 = +s3; // 值变成 NaN
  b = +b; // 值变成数值 0
  f = +f; // 不变，还是 1.1
  o = +o; // 值变成数值-1
  let s1 = "01";
  let s2 = "1.1";
  let s3 = "z";
  let b = false;
  let f = 1.1;
  let o = {
  valueOf() {
  return -1;
  }
  };
  s1 = -s1; // 值变成数值-1
  s2 = -s2; // 值变成数值-1.1
  s3 = -s3; // 值变成 NaN
  b = -b; // 值变成数值 0
  f = -f; // 变成-1.1
  o = -o; // 值变成数值 1

```

2. 位操作符
   先把值转换成 32 位进行操作，结果再转换成 64 位。负数先转换成二进制，再补 1

```js
let num1 = 25; // 二进制 00000000000000000000000000011001
let num2 = ~num1; // 二进制 11111111111111111111111111100110
console.log(num2); // -26
let result = 25 & 3;
console.log(result); // 1  按位与操作在两个位都是 1 时返回 1，在任何一位是 0 时返回 0。
let result = 25 | 3;
console.log(result); // 27 按位或操作在至少一位是 1 时返回 1，两位都是 0 时返回 0。
let result = 25 ^ 3;
console.log(result); // 26 按位异或与按位或的区别是，它只在一位上是 1 的时候返回 1（两位都是 1 或 0，则返回 0）。
let oldValue = 2; // 等于二进制 10
let newValue = oldValue << 5; // 等于二进制 1000000，即十进制 64
let oldValue = 64; // 等于二进制 1000000
let newValue = oldValue >> 5; // 有符号右移，等于二进制 10，即十进制 2
let newValue = oldValue >>> 5; //有无符号右移 等于二进制 10，即十进制 2
let oldValue = -64; // 等于二进制 11111111111111111111111111000000
let newValue = oldValue >>> 5; //无符号右移 等于十进制 134217726
```

3. 布尔操作符

```js
console.log(!false); // true
console.log(!"blue"); // false
console.log(!0); // true
console.log(!NaN); // true
console.log(!""); // true
console.log(!12345); // false
// &&
// ||
```

4. 乘性操作符(乘法、除法和取模)
5. 指数操作符

```js
Math.pow();
//let squared = 3;
// squared **= 2;
//console.log(squared); // 9
```

6. 加性操作符

```js
let num1 = 5;
let num2 = 10;
let message = "The sum of 5 and 10 is " + num1 + num2;
console.log(message); // "The sum of 5 and 10 is 510"
let result1 = 5 - true; // true 被转换为 1，所以结果是 4
let result2 = NaN - 1; // NaN
let result3 = 5 - 3; // 2
let result4 = 5 - ""; // ""被转换为 0，所以结果是 5
let result5 = 5 - "2"; // "2"被转换为 2，所以结果是 3
let result6 = 5 - null; // null 被转换为 0，所以结果是 5
```

7. 关系操作符
8. 相等操作符
9. 条件操作符
10. 赋值操作符
11. 逗号操作符

---

语句

1. 标签语句

```js
//可以在后面通过 break 或 continue 语句引用
label: statement;
start: for (let i = 0; i < count; i++) {
  console.log(i);
}
```

for-in 循环: 变量是 null 或者 undefined 时不执行循环体
for-of 循环：用于遍历可迭代的变量是 null 或者 undefined,则不执行循环体

---

函数

# 第 4 章 变量、作用域与内存

## 4.1 原始值与引用值

原始值就是最简单的数据`按值访问`，引用值则是由多个值构成的对象。`按引用访问`

### 4.1.1 动态属性

对引用值，可以随时添加、修改和删除其属性和方法。
原始类型的初始化可以只使用原始字面量形式。

```js
let name2 = new String("Matt");
name2.age = 26;
console.log(name2.age); // 26
```

### 4.1.2 复制值

      原始值：保存一个副本，前后互不影响。栈内存。
      引用值：指向一个指针，同一个对象，堆内存。

### 4.1.3 传递参数

ECMAScript 中所有函数的参数都是按值传递的。

```js
function setName(obj) {
  obj.name = "Nicholas";
  obj = new Object();
  obj.name = "Greg";
}
let person = new Object();
setName(person);
console.log(person.name); // "Nicholas"
```

### 4.1.4 确定类型

instanceof 操作符:判断引用值。

## 4.2 执行上下文与作用域

变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象（variable object），而这个上下文中定义的所有变量和函数都存在于这个对象上。<br/>
上下文在其所有的代码都执行完毕后会被销毁。`上下文栈`<br/>
`作用域链`：上下文中的代码在执行的时候，会创建变量对象的一个作用域链。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。`函数参数被认为是当前上下文中的变量。`
执行上下文分全局上下文、函数上下文和块级上下文。

### 4.2.1 作用域增强

`执行上下文`：全局上下文和函数上下文（eval()调用内部存在）

```js
try/catch 语句的 catch 块
with 语句
```

### 4.2.2 变量声明

    1. 使用var的函数作用域声明
    2. 使用let的块级作用域声明,使用{}界定。
    是在同一作用域内不能声明两次，会抛出 SyntaxError
    3. 使用const的常量声明
    4. 标识符搜索

## 4.3 垃圾回收

    通过自动内存管理实现内存分配和闲置资源回收。过程是周期性的。

### 4.3.1 标记清理

    当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。

### 4.3.2 引用计数

    如果同一个值又被赋给另一个变量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了

### 4.3.3 性能

    现代垃圾回收程序会基于对 JavaScript 运行时环境的探测来决定何时运行。探测机制因引擎而异，但基本上都是根据已分配对象的大小和数量来判断的。

### 4.3.4 内存管理

    优化内存管理的方法：解除引用。
    1. 通过 const 和 let 声明提升性能
    2. 隐藏类和删除操作
    3. 内存泄露
    4. 静态分配与对象池
    减少浏览器运行回收程序，对象的更替速度。
    浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度

# 第 5 章 基本引用类型

引用值是某个特定引用类型的实例。

## 5.1 Date

```js
Date.parse() //尝试将这个字符串转换为表示该日期的毫秒数。
Date.UTC() //参数是年、零起点月数（1 月是 0，2 月是 1，以此类推）、日（1~31）、时（0~23）、分、秒和毫秒。
// 5.1.1 继承的方法
toLocaleString() //方法返回与浏览器运行的本地环境一致的日期和时间。有上午和下午
toString() //返回带时区信息的日期和时间，而时间也是以 24 小时制（0~23）表示的
valueOf() //返回的是日期的毫秒表示
// 日期的格式化方式
toDateString()显示日期中的周几、月、日、年（格式特定于实现）；
toTimeString()显示日期中的时、分、秒和时区（格式特定于实现）；
toLocaleDateString()显示日期中的周几、月、日、年（格式特定于实现和地区）；
toLocaleTimeString()显示日期中的时、分、秒（格式特定于实现和地区）；
toUTCString()显示完整的 UTC 日期（格式特定于实现）。
// 日期/时间组件的方法
----
```

## 5.2 RegExp

```js
g：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。
i：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。
m：多行模式，表示查找到一行文本末尾时会继续查找。
y：粘附模式，表示只查找从 lastIndex 开始及之后的字符串。
u：Unicode 模式，启用 Unicode 匹配。
s：dotAll 模式，表示元字符.匹配任何字符（包括\n 或\r）。
// 5.2.1 RegExp 实例属性
global：布尔值，表示是否设置了 g 标记。
ignoreCase：布尔值，表示是否设置了 i 标记。
unicode：布尔值，表示是否设置了 u 标记。
sticky：布尔值，表示是否设置了 y 标记。
lastIndex：整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始。
multiline：布尔值，表示是否设置了 m 标记。
dotAll：布尔值，表示是否设置了 s 标记。
source：正则表达式的字面量字符串（不是传给构造函数的模式字符串），没有开头和结尾的斜杠。
flags：正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回（没有前后斜杠）。
//5.2.2 RegExp 实例方法
exec()，主要用于配合捕获组使用
test()，如果输入的文本与模式匹配，则参数返回 true，否则返回 false。
//5.2.3 RegExp 构造函数属性
//5.2.4 模式局限
\A 和\Z 锚（分别匹配字符串的开始和末尾）
联合及交叉类
原子组
x（忽略空格）匹配模式
条件式匹配
正则表达式注释
```

## 5.3 原始值包装类型

```js
// Boolean、Number 和 String
//每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。
let numberObject = new Number(10);
let numberValue = 10;
console.log(typeof numberObject); // "object"
console.log(typeof numberValue); // "number"
// 字符串的迭代与结构 for..of
localeCompare(); //字符串的比较
```

## 5.4 单例内置对象

Object、Array 、String、Global、Math。

### 5.4.1 Global

```js
encodeURI() encodeURIComponent() //URL编码
decodeURI()和 decodeURIComponent() //URL解码
eval() //完整的ECMAScript 解释器
//3. Global对象属性。Function为Function的构造函数对象
//4. window 对象
//虽然 ECMA-262 没有规定直接访问 Global 对象的方式，但浏览器将 window 对象实现为 Global对象的代理。
```

### 5.4.2 Math

# 第 6 章 集合引用类型

## 6.1 Object

```js
//创建对象的两种方式：对象字面量和构造函数
// 对象的属性值的获取：中括号和点
let person = {}; // 与 new Object()相同
person.name = "Nicholas";
person.age = 29;
console.log(person["name"]); // "Nicholas"
console.log(person.name); // "Nicholas"，一般属性名中包含一种空格，则不采用
```

## 6.2 Array

```js
// 创建数组的方式：构造函数、数组字面量
// Array.from，将类数组转换成数组，①字符串的拆分 ②可以使用 from()将集合和映射转换为一个新数组 ③浅复制 ④可以使用任何可迭代的对象
console.log(Array.from("Matt")); // ["M", "a", "t", "t"]
const a1 = [1, 2, 3, 4];
const a2 = Array.from(a1, (x) => x ** 2);
const a3 = Array.from(
  a1,
  function(x) {
    return x ** this.exponent;
  },
  { exponent: 2 }
);
console.log(a2); // [1, 4, 9, 16]
console.log(a3); // [1, 4, 9, 16]
// 数组空位
// ES6将这些方法中空位当成已存在的元素，置为undefined
const a = Array.from([, , ,]); // 使用 ES6 的 Array.from()创建的包含 3 个空位的数组
for (const val of a) {
  alert(val === undefined);
}
// true
// true
// true
// 数组索引
let colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
colors[99] = "black"; // 添加一种颜色（位置 99）
alert(colors.length); // 100
// 检测数组
value instanceof Array;
Array.isArray();
// 迭代器方法
const a = ["foo", "bar", "baz", "qux"];
const aKeys = Array.from(a.keys());
const aValues = Array.from(a.values());
const aEntries = Array.from(a.entries());
console.log(aKeys); // [0, 1, 2, 3]
console.log(aValues); // ["foo", "bar", "baz", "qux"]
console.log(aEntries); // [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]]
// 复制和填充的方法
copyWithin();
fill();
// 转换方法
let colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
alert(colors.toString()); // red,blue,green
alert(colors.valueOf()); // red,blue,green
alert(colors); // red,blue,green
// 栈方法
push();
pop();
// 队列的方法
shift();
unshift();
// 排序的方法
reserve();
sort();
// 操作方法
concat();
slice();
splice();
// 搜索和位置
indexOf();
lastIndexOf();
includes();
find();
findIndex();
// 迭代方法
every();
filter();
map();
some();
forEach();
// 归并方法
reduce();
reduceRight();
```

## 6.3 定型数组

      它所指的其实是一种特殊的包含数值类型的数组。包含一套不同的引用类型，用于管理数值在内存中的类型。
      解决的问题是WebGL中底层数组之间转换困难的问题。
      这是一个提供JavaScript 接口的、C 语言风格的浮点值数组。JavaScript 运行时使用这个类型可以分配、读取和写入数组。这个数组可以直接传给底层图形驱动程序 API，也可以直接从底层获取到。

### 6.3.1 ArrayBuffer

`Float32Array`(是定型数组的一个类型) 实际上是一种“视图”，可以允许 JavaScript 运行时访问一块名为 ArrayBuffer 的预分配内存。ArrayBuffer 是所有定型数组及视图引用的基本单位。

```js
// ArrayBuffer()是一个普通的 JavaScript 构造函数，可用于在内存中分配特定数量的字节空间。
const buf = new ArrayBuffer(16); // 在内存中分配 16 字节
alert(buf.byteLength); // 16
// ArrayBuffer 一经创建就不能再调整大小。可以通过slice
```

### 6.3.2 DataView

第一种允许你读写 `ArrayBuffer 的视图`是 `DataView`。这个视图专为文件 I/O 和网络 I/O 设计，其 API 支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些。DataView 对缓冲内容没有任何预设，也不能迭代。

```js
ElementType; //存储在缓冲内的数据类型
// 字节序：大端字节序和小端字节序
// 边界情形
```

### 6.3.3 定型数组

另一种形式的`ArrayBuffer 的视图`,它特定于一种 ElementType 且遵循系统原生的字节序。

## 6.4 Map

键值存储的机制。
`和Object区别`：Map 可以使用任何 JavaScript 数据类型作为键。Map 实例会维护键值对的插入顺序

```js
set()  //添加
get() has() //查询
size() //数量
delete() clear() //删除
// 顺序与迭代
// 选择Object还是map
```

## 6.5 WeakMap

描述的是 JavaScript 垃圾回收程序对待“弱映射”中键的方式。<br/>
弱映射中的键只能是 Object 或者继承自 Object 的类型<br/>
不会影响垃圾回收机制。

```js
//因为 WeakMap 中的键/值对任何时候都可能被销毁，所以没必要提供迭代其键/值对的能力
// 使用弱映射
1. 私有变量
2. DOM节点元数据
```

## 6.6 Set

一种数据集合，其中可以包含任何 js 类型作为值.和 map 的区别：map 是一种映射，有键和值。

## 6.7 WeakSet

## 6.8 迭代与扩展操作(for..of.)

```js
Array;
所有定型数组;
Map;
Set;
let arr1 = [1, 2, 3];
// 把数组复制到定型数组
let typedArr1 = Int16Array.of(...arr1);
let typedArr2 = Int16Array.from(arr1);
console.log(typedArr1); // Int16Array [1, 2, 3]
console.log(typedArr2); // Int16Array [1, 2, 3]
// 把数组复制到映射
let map = new Map(arr1.map((x) => [x, "val" + x]));
console.log(map); // Map {1 => 'val 1', 2 => 'val 2', 3 => 'val 3'}
// 把数组复制到集合
let set = new Set(typedArr2);
console.log(set); // Set {1, 2, 3}
// 把集合复制回数组
let arr2 = [...set];
console.log(arr2); // [1, 2, 3]
```
