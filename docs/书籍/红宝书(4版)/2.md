---
title: js高级程序设计(4版2)
date: 2021-05-25
permalink:
categories:
  - js高级程序设计
tags:
  - js高级程序设计
---

# 第 7 章 迭代器与生成器

## 7.1 理解迭代

循环是迭代机制的基础。

## 7.2 迭代器模式

```js
1. 可迭代对象
特点：它们包含的元素都是有限的，而且都具有无歧义的遍历顺序。
2. 迭代器
按需创建的一次性对象，每个迭代器都会关联一个可迭代的对象，而迭代器会暴露迭代其关联可迭代对象的API
3. 可迭代协议（Iterable 接口）
具备的能力：支持迭代的自我识别能力、迭代的自我识别能力
`在 ECMAScript 中，这意味着必须暴露一个属性作为“默认迭代器”，而且这个属性必须使用特殊的 Symbol.iterator 作为键。这个默认迭代器属性必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器。`
"默认迭代器"：
// let str="123"
//console.log(str[Symbol.iterator]); // f values() { [native code] }
// 调用这个工厂函数会生成一个迭代器
// console.log(str[Symbol.iterator]()); // StringIterator {}
4. 内置类型都实现了 Iterable 接口
字符串、数组、映射、集合、arguments对象、NodeList等DOM集合类型
5. 接口可迭代对象的原生语言特性包括：
for-of循环、数组解构、扩展运算符、Array.from()、创建集合、创建映像、Promise.all()、promise.race()、yield*在生成器中的使用
6. 迭代器协议
迭代器 API 使用 next()方法。在可迭代对象中遍历数据。每次成功调用 next()，都会返回一个 IteratorResult 对象，其中包含迭代器返回的下一个值。若不调用 next()，则无法知道迭代器的当前位置。
// console.log(iter.next()); // { done: false, value: 'foo' }
7. 自定义迭代器
class Counter {
  constructor(limit) {
    this.limit = limit;
    }
    [Symbol.iterator]() {
    let count = 1,
    limit = this.limit;
    return {
      next() {
        if (count <= limit) {
        return { done: false, value: count++ };
        } else {
        return { done: true, value: undefined };
        }
      }
  };
 }
}
let counter = new Counter(3);
for (let i of counter) { console.log(i); }
// 1
// 2
// 3
8. 提前终止迭代器
场景：1. for-of 循环通过 break、 continue、 return 或 throw 提前退出
      2. 解构操作并未消费所有值
有的迭代器是不能终止的，比如数组
```

## 7.3 生成器

```js
1. 生成器基础
拥有在一个函数块内暂停和恢复代码执行的能力。
函数名称前带*，则表示是生成器
`箭头函数不能来定义生成器函数`
生成器对象实现了 Iterable 接口
2. 通过yield终端执行
function* generatorFn() {
  yield 'foo';
  yield 'bar';
  return 'baz';
}
let generatorObject = generatorFn(); //generatorObject 生成器对象（调用生成器的对象）
console.log(generatorObject.next()); // { done: false, value: 'foo' }
console.log(generatorObject.next()); // { done: false, value: 'bar' }
console.log(generatorObject.next()); // { done: true, value: 'baz' }
- 生成器对象作为可迭代对象
function* generatorFn() {
  yield 1;
  yield 2;
  yield 3;
}
for (const x of generatorFn()) {
  console.log(x);
}
// 1
// 2
// 3
- 使用 yield 实现输入和输出
function* generatorFn(initial) {
  console.log(initial);
  console.log(yield);
  console.log(yield);
}
let generatorObject = generatorFn('foo');
generatorObject.next('bar'); // foo
generatorObject.next('baz'); // baz
generatorObject.next('qux'); // qux
- 产生可迭代的对象
// 等价的 generatorFn：
// function* generatorFn() {
// for (const x of [1, 2, 3]) {
// yield x;
// }
// }
function* generatorFn() {
yield* [1, 2, 3];
}
- 使用yield实现递归算法
function* nTimes(n) {
  if (n > 0) {
  yield* nTimes(n - 1);
  yield n - 1;
  }
}
for (const x of nTimes(3)) {
console.log(x);
}
// 0
// 1
// 2
3. 生成器作为默认迭代器
class Foo {
  constructor() {
  this.values = [1, 2, 3];
  }
  * [Symbol.iterator]() {
  yield* this.values;
  }
}
const f = new Foo();
for (const x of f) {
console.log(x);
}
// 1
// 2
// 3
4. 提前终止生成器
- return
return()方法会强制生成器进入关闭状态。提供给 return()方法的值，就是终止迭代器对象的值
- throw
throw()方法会在暂停的时候将一个提供的错误注入到生成器对象中。如果错误未被处理，生成器就会关闭：
```

# 第 8 章 对象、类与面向对象编程

## 8.1 理解对象

对象的本质：就是一组没有特定顺序的值

```js
1. 属性的类型
 - 数据属性 [[Configurable]] [[Enumerable]] [[Writable]] [[Value]]

 - 访问器属性 它们包含一个获取（ getter）函数和一个设置（ setter）函数
  特性：[[Configurable]] [[Enumerable]] [[Get]] [[Set]]
  Object.defineProperty()：修改属性的值和定义访问器的属性
2. 定义多个属性
Object.defineProperties()
3. 读取属性的特性
Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符
4. 合并对象
Object.assign()---浅复制
将每个源对象中可枚举（ Object.propertyIsEnumerable()返回 true）和自有（ Object.hasOwnProperty()返回 true）属性复制到目标对象
5. 对象标识及相等判定
 Object.is(参数1,参数2)
6. 增强的对象语法
 - 属性值的简写
 - 可计算属性（属性名用中括号）
 - 简写方法名
7. 对象解构
```

## 8.2 创建对象

```js
1. 工厂模式：在函数中创建一个对象并返回
2. 构造函数模式：
function Person(name, age, job){
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function() {
  console.log(this.name);
  };
}
缺点：方法在每个实例上都会创建一次
3. 原型模式
多个实例对象之间共享属性和方法
Object.getPrototypeOf()，返回参数的内部特性[[Prototype]]的值
Object.setPrototypeOf()，设置参数的内部特性[[Prototype]]的值
for-in 循环和 Object.keys()的枚举顺序是不确定的，取决于 JavaScript 引擎，可能因浏览器而异。
Object.getOwnPropertyNames()、 Object.getOwnPropertySymbols()和 Object.assign()的枚举顺序是确定性的。
4. 对象迭代
```

## 8.3 继承

```js
1. 原型链
判断实例是否在原型上的方式：isPrototypeOf() instanceOf()
`以对象字面量方式创建原型方法会破坏之前的原型链`
// 继承 SuperType
SubType.prototype = new SuperType();
SubType.prototype = {
  getSubValue() {
  return this.subproperty;
  },
  someOtherMethod() {
  return false;
  }
};
缺点：1. 子类型在实例化时不能给父类型的构造函数传参  2. 所有的属性、方法共享。原型中的引用值的问题
2. 盗用构造函数（经典继承）
在子类构造函数中调用父类构造函数
缺点：1. 必须在构造函数中定义方法 2. 子类不能访问父类原型上定义的方法
3. 组合继承
使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性
缺点：父类构造函数会被调用两次，效率低
4. 原型式继承
// 对对象的一层浅复制
function object(o) {
  function F() {}
  F.prototype = o;
  return new F();
}
// 传一个参数时，与Object函数的功能一致
Object.create()
特点：不需要单独创建构造函数
5. 寄生式继承
function createAnother(original){
  let clone = object(original); // 通过调用函数创建一个新对象
  clone.sayHi = function() { // 以某种方式增强这个对象
  console.log("hi");
  };
  return clone; // 返回这个对象
}
6. 寄生式组合继承
通过盗用构造函数继承属性，但使用混合式原型链继承方法
function inheritPrototype(subType, superType) {
  let prototype = object(superType.prototype); // 创建对象
  prototype.constructor = subType; // 增强对象
  subType.prototype = prototype; // 赋值对象
}
```

## 8.4 类

函数受函数作用域限制，而类受块作用域限制。
类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法

```js
1. 类构造函数
调用类构造函数必须使用 new 操作符，否则会抛出错误
2. 实例、原型和类成员
实例成员：每个实例都对应一个唯一的成员对象，这意味着所有成员都不会在原型上共享
静态类成员：定义在类本身上，用static
3. 继承
class Vehicle {
  identifyPrototype(id) {
    console.log(id, this);
  }
  static identifyClass(id) {
    console.log(id, this);
  }
}
class Bus extends Vehicle {}
let v = new Vehicle();
let b = new Bus();

- 派生类的方法可以通过 super 关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于类构造函数、实例方法和静态方法内部。
- 类构造函数中，不能在 super() 之前使用this
- 在实例化时检测 new.target 是不是抽象基类，可以阻止对抽象基类的实例化
```

# 第 9 章 代理与反射

代理是一个抽象的目标对象

## 9.1 代理基础

```js
// 两个参数，第一个是目标对象，第二个是处理函数
// 使用严格模式可以区分开代理和目标对象
const target = {
 id: 'target'
};
const handler = {};
const proxy = new Proxy(target, handler);
// id 属性会访问同一个值
console.log(target.id); // target
console.log(proxy.id); // target
-------------------------
定义捕获器
const target = {
 foo: 'bar'
};
const handler = {
 // 捕获器在处理程序对象中以方法名为键
  get(trapTarget, property, receiver) {
    // 目标对象、要查询的属性、代理对象
    console.log(trapTarget === target);
    console.log(property);
    console.log(receiver === proxy);
  }
};
const proxy = new Proxy(target, handler);
proxy.foo;
// true
// foo
// true
------------------------
全局Reflect对象
 const handler = {
 get() {
   return Reflect.get(...arguments);
  // 简洁写法 get: Reflect.get
 }
};
-------------------------
捕获器不变式：对于捕获器的变量不能重复，重复报错
-----------------------
可撤销代理
const target = {
 foo: 'bar'
};
const handler = {
 get() {
 return 'intercepted';
 }
};
const { proxy, revoke } = Proxy.revocable(target, handler);
console.log(proxy.foo); // intercepted
console.log(target.foo); // bar
revoke();
console.log(proxy.foo); // TypeError
-----------------------
实用反射API
1. 反射API与对象API
2. 状态标记
const o = {};
if(Reflect.defineProperty(o, 'foo', {value: 'bar'})) {
 console.log('success');
} else {
 console.log('failure');
}
以下反射方法都会提供状态标记：
Reflect.defineProperty()
Reflect .preventExtensions()
Reflect.setPrototypeOf()
Reflect.set()
Reflect.deleteProperty()
3. 用一等函数替代操作符
以下反射方法提供只有通过操作符才能完成的操作。
Reflect.get()：可以替代对象属性访问操作符。
Reflect.set()：可以替代=赋值操作符。
Reflect.has()：可以替代 in 操作符或 with()。  Reflect.deleteProperty()：可以替代 delete 操作符。
Reflect.construct()：可以替代 new 操作符。
4. 安全地应用函数
-----------------------------
代理另一个代理
-----------------------------
代理的问题与不足
1. 代理中的this- 如果目标对象依赖于对象标识，就碰到意料之外的问题
const wm = new WeakMap();
class User {
 constructor(userId) {
 wm.set(this, userId);
 }
 set id(userId) {
 wm.set(this, userId);
 }
 get id() {
 return wm.get(this);
 }
}
const user = new User(123);
console.log(user.id); // 123
const userInstanceProxy = new Proxy(user, {});
console.log(userInstanceProxy.id); // undefined
2. 代理与内部槽位
const proxy = new Proxy(target, {});
console.log(proxy instanceof Date); // true
proxy.getDate(); // TypeError: 'this' is not a Date object
-----------------------------------

```

## 9.2 代理捕获器与反射方法

```js
get()捕获器会在获取属性值的操作中被调用。对应的反射 API 方法为 Reflect.get()。
set()捕获器会在设置属性值的操作中被调用。对应的反射 API 方法为 Reflect.set()。
has()捕获器会在 in 操作符中被调用。对应的反射 API 方法为 Reflect.has()。
defineProperty()捕获器会在 Object.defineProperty()中被调用。对应的反射 API 方法为Reflect.defineProperty()。
getOwnPropertyDescriptor()捕获器会在 Object.getOwnPropertyDescriptor()中被调用。对应的反射 API 方法为 Reflect.getOwnPropertyDescriptor()。
deleteProperty()捕获器会在 delete 操作符中被调用。对应的反射 API 方法为 Reflect. deleteProperty()。
ownKeys()捕获器会在 Object.keys()及类似方法中被调用。对应的反射 API 方法为 Reflect. ownKeys()。
getPrototypeOf()捕获器会在 Object.getPrototypeOf()中被调用。对应的反射 API 方法为Reflect.getPrototypeOf()。
setPrototypeOf()捕获器会在 Object.setPrototypeOf()中被调用。对应的反射 API 方法为Reflect.setPrototypeOf()。
isExtensible()捕获器会在 Object.isExtensible()中被调用。对应的反射 API 方法为Reflect.isExtensible()。
preventExtensions()捕获器会在 Object.preventExtensions()中被调用。对应的反射 API方法为 Reflect.preventExtensions()。
apply()捕获器会在调用函数时中被调用。对应的反射 API 方法为 Reflect.apply()。
construct()捕获器会在 new 操作符中被调用。对应的反射 API 方法为 Reflect.construct()。
```

## 9.3 代理模式

### 9.3.1 跟踪属性访问

通过 get set 等，可以知道对象属性的访问时间和位置，被监控。

### 9.3.2 隐藏属性

### 9.3.3 属性验证

### 9.3.4 函数与构造函数参数验证

### 9.3.5 数据绑定与可观察式对象

```js
const userList = [];
function emit(newValue) {
  console.log(newValue);
}
const proxy = new Proxy(userList, {
  set(target, property, value, receiver) {
    const result = Reflect.set(...arguments);
    if (result) {
      emit(Reflect.get(target, property, receiver));
    }
    return result;
  },
});
proxy.push("John");
// John
proxy.push("Jacob");
// Jacob
```

# 第 10 章 函 数

## 10.1 箭头函数

```js
//
// 使用大括号就说明包含“函数体”，可以在一个函数中包含多条语句，跟常规的函数一样。如果不使用大括号，那么箭头后面就只能有一行代码，
// 比如一个赋值操作，或者一个表达式。
// 缺点
箭头函数不能使用 arguments、super 和 new.target，也不能用作构造函数。此外，箭头函数也没有 prototype 属性。
```

## 10.2 函数名

```js
// 函数名是指向函数的指针。
// 将一个函数名赋值给一个变量，则变量相当于函数。
ECMAScript 6 的所有函数对象都会暴露一个只读的 name 属性，其中包含关于函数的信息。
function foo() {}
let bar = function() {};
let baz = () => {};
console.log(foo.name); // foo
console.log(bar.name); // bar
console.log(baz.name); // baz
console.log((() => {}).name); //（空字符串）
console.log((new Function()).name); // anonymous
```

## 10.3 理解参数

```js
// ECMAScript 函数的参数在内部表现为一个数组
arguments 对象是一个类数组对象
// 箭头函数中的参数，而只能通过定义的命名参数访问。
function foo() {
 let bar = () => {
 console.log(arguments[0]); // 5
 };
 bar();
}
foo(5);
```

## 10.4 没有重载

后边定义的会覆盖前面定义的

## 10.5 默认参数值

```js
function makeKing(name = 'Henry') {
 return `King ${name} VIII`;
}
// 在使用默认参数时，arguments 对象的值不反映参数的默认值，只反映传给函数的参数。
// 默认参数值并不限于原始值或对象类型，也可以使用调用函数返回的值。在调用时才会求值
let romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI'];
let ordinality = 0;
function getNumerals() {
 // 每次调用后递增
 return romanNumerals[ordinality++];
}
function makeKing(name = 'Henry', numerals = getNumerals()) {
 return `King ${name} ${numerals}`;
}
console.log(makeKing()); // 'King Henry I'
console.log(makeKing('Louis', 'XVI')); // 'King Louis XVI'
console.log(makeKing()); // 'King Henry II'
console.log(makeKing()); // 'King Henry III'
// 默认参数作用域与暂时性死区
参数初始化顺序遵循“暂时性死区”规则，即前面定义的参数不能引用后面定义的.
参数也存在于自己的作用域中，它们不能引用函数体的作用域：
```

## 10.6 参数扩展与收集

扩展运算符的使用场景：函数定义中的参数列表

```js
let getSum = (a, b, c = 0) => {
 return a + b + c;
}
console.log(getProduct(...[1,2])); // 2
console.log(getProduct(...[1,2,3])); // 6
console.log(getProduct(...[1,2,3,4])); // 6
// 收集参数的前面如果还有命名参数，则只会收集其余的参数；如果没有则会得到空数组。因为收集参数的结果可变，所以只能把它作为最后一个参数：
function getProduct(...values, lastValue) {}
// 可以
function ignoreFirst(firstValue, ...values) {
 console.log(values);
}
```

## 10.7 函数声明与函数表达式

```js
// JavaScript 引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。
// 而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。
// 函数的提升
console.log(sum(10, 10));
let sum = function (num1, num2) {
  return num1 + num2;
};
```

## 10.8 函数作为值

```js
function add10(num) {
  return num + 10;
}
let result1 = callSomeFunction(add10, 10);
console.log(result1); // 20
// 也可以返回一个函数，sort函数
```

## 10.9 函数内部

```js
// arguments
function factorial(num) {
 if (num <= 1) {
 return 1;
 } else {
 return num * arguments.callee(num - 1);
 }
}
// this
// this谁调用就指向谁
// 箭头函数中this指的是定义箭头函数的上下文
----------------------------------------------
// caller 。这个属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为 null。
function outer() {
 inner();
}
function inner() {
 console.log(inner.caller);
 console.log(arguments.callee.caller); //严格模式下会报错
}
outer();
---------------------------------------------
new.target
//检测函数是否使用 new 关键字调用的 new.target 属性,如果正常调用，则显示undefined,如果new关键字调用，则显示被调用的构造函数
```

## 10.10 函数属性与方法

```js
length; //函数点工艺的命名参数的个数
prototypes属性;
function sum(num1, num2) {
  return num1 + num2;
}
function callSum1(num1, num2) {
  return sum.apply(this, arguments); // 传入 arguments 对象
}
function callSum(num1, num2) {
  return sum.call(this, num1, num2); //逐个传递
}
window.color = "red";
var o = {
  color: "blue",
};
function sayColor() {
  console.log(this.color);
}
let objectSayColor = sayColor.bind(o); //将this值被绑定到传给bind()对象
objectSayColor(); // blue
```

## 10.11 函数表达式

```js
let functionName = function (arg0, arg1, arg2) {
  // 函数体
};
// 匿名函数(兰姆达函数)
```

## 10.12 递归

```js
const factorial = function f(num) {
  if (num <= 1) {
    return 1;
  } else {
    return num * f(num - 1);
  }
};
```

## 10.13 尾调用优化

```js
代码在严格模式下执行；
外部函数的返回值是对尾调用函数的调用；
尾调用函数返回后不需要执行额外的逻辑；
尾调用函数不是引用外部函数作用域中自由变量的闭包。
```

## 10.14 闭包

```js
window.identity = 'The Window';
let object = {
 identity: 'My Object',
 getIdentityFunc() {
 return function() {
   return this.identity;
  };
 }
 console.log(object.getIdentityFunc()()); // 'The Window'
 object.getIdentity(); // 'My Object'
(object.getIdentity)(); // 'My Object'
(object.getIdentity = object.getIdentity)(); // 'The Window'
};
console.log(object.getIdentityFunc()()); // 'The Window'
```

## 10.15 立即调用的函数表达式

## 10.16 私有变量

```js
// 私有变量包括函数参数、局部变量，以及函数内部定义的其他函数。
// 特权方法（privileged method）是能够访问函数私有变量（及私有函数）的公有方法
function MyObject() {
 // 私有变量和私有函数
 let privateVariable = 10;
 function privateFunction() {
 return false;
 }
 // 特权方法，构造函数中实现
 this.publicMethod = function() {
 privateVariable++;
 return privateFunction();
 };
}
-------------------
 this.getName = function() {
 return name;
 };
 this.setName = function (value) {
 name = value;
 };
}
let person = new Person('Nicholas');
console.log(person.getName()); // 'Nicholas'
person.setName('Greg');
console.log(person.getName()); // 'Greg'
----------------------
私有变量和闭包会导致作用域链变长。
---------------------
// 模块模式
// 模块模式是在单例对象基础上加以扩展，使其通过作用域链来关联私有变量和特权方法
let singleton = function() {
 // 私有变量和私有函数
 let privateVariable = 10;
 function privateFunction() {
 return false;
 }
 // 特权/公有方法和属性
 return {
  publicProperty: true,
  publicMethod() {
  privateVariable++;
  return privateFunction();
  }
 };
}();
```
