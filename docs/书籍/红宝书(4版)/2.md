---
title: js高级程序设计(4版2)
date: 2021-05-25
permalink:
categories: 
  - js高级程序设计
tags: 
  - js高级程序设计
---
# 第7章 迭代器与生成器

# 第8章 对象、类与面向对象编程
# 第9章 代理与反射
代理是一个抽象的目标对象
## 9.1 代理基础
```js
// 两个参数，第一个是目标对象，第二个是处理函数
// 使用严格模式可以区分开代理和目标对象
const target = { 
 id: 'target' 
}; 
const handler = {}; 
const proxy = new Proxy(target, handler); 
// id 属性会访问同一个值
console.log(target.id); // target 
console.log(proxy.id); // target
-------------------------
定义捕获器
const target = { 
 foo: 'bar' 
}; 
const handler = { 
 // 捕获器在处理程序对象中以方法名为键
  get(trapTarget, property, receiver) { 
    // 目标对象、要查询的属性、代理对象
    console.log(trapTarget === target); 
    console.log(property); 
    console.log(receiver === proxy); 
  }
}; 
const proxy = new Proxy(target, handler);
proxy.foo; 
// true 
// foo 
// true
------------------------
全局Reflect对象
 const handler = { 
 get() { 
   return Reflect.get(...arguments);
  // 简洁写法 get: Reflect.get 
 } 
};
-------------------------
捕获器不变式：对于捕获器的变量不能重复，重复报错
-----------------------
可撤销代理
const target = { 
 foo: 'bar' 
}; 
const handler = { 
 get() { 
 return 'intercepted'; 
 } 
}; 
const { proxy, revoke } = Proxy.revocable(target, handler); 
console.log(proxy.foo); // intercepted 
console.log(target.foo); // bar 
revoke(); 
console.log(proxy.foo); // TypeError
-----------------------
实用反射API
1. 反射API与对象API
2. 状态标记
const o = {}; 
if(Reflect.defineProperty(o, 'foo', {value: 'bar'})) { 
 console.log('success'); 
} else { 
 console.log('failure'); 
} 
以下反射方法都会提供状态标记：
Reflect.defineProperty()
Reflect .preventExtensions()
Reflect.setPrototypeOf()
Reflect.set()
Reflect.deleteProperty()
3. 用一等函数替代操作符
以下反射方法提供只有通过操作符才能完成的操作。
Reflect.get()：可以替代对象属性访问操作符。
Reflect.set()：可以替代=赋值操作符。
Reflect.has()：可以替代 in 操作符或 with()。  Reflect.deleteProperty()：可以替代 delete 操作符。
Reflect.construct()：可以替代 new 操作符。
4. 安全地应用函数
-----------------------------
代理另一个代理
-----------------------------
代理的问题与不足
1. 代理中的this- 如果目标对象依赖于对象标识，就碰到意料之外的问题
const wm = new WeakMap(); 
class User { 
 constructor(userId) { 
 wm.set(this, userId); 
 } 
 set id(userId) { 
 wm.set(this, userId); 
 } 
 get id() { 
 return wm.get(this); 
 } 
}
const user = new User(123); 
console.log(user.id); // 123 
const userInstanceProxy = new Proxy(user, {}); 
console.log(userInstanceProxy.id); // undefined
2. 代理与内部槽位
const proxy = new Proxy(target, {}); 
console.log(proxy instanceof Date); // true 
proxy.getDate(); // TypeError: 'this' is not a Date object
-----------------------------------

```
## 9.2 代理捕获器与反射方法
```js
get()捕获器会在获取属性值的操作中被调用。对应的反射 API 方法为 Reflect.get()。
set()捕获器会在设置属性值的操作中被调用。对应的反射 API 方法为 Reflect.set()。
has()捕获器会在 in 操作符中被调用。对应的反射 API 方法为 Reflect.has()。
defineProperty()捕获器会在 Object.defineProperty()中被调用。对应的反射 API 方法为Reflect.defineProperty()。
getOwnPropertyDescriptor()捕获器会在 Object.getOwnPropertyDescriptor()中被调用。对应的反射 API 方法为 Reflect.getOwnPropertyDescriptor()。
deleteProperty()捕获器会在 delete 操作符中被调用。对应的反射 API 方法为 Reflect. deleteProperty()。
ownKeys()捕获器会在 Object.keys()及类似方法中被调用。对应的反射 API 方法为 Reflect. ownKeys()。
getPrototypeOf()捕获器会在 Object.getPrototypeOf()中被调用。对应的反射 API 方法为Reflect.getPrototypeOf()。
setPrototypeOf()捕获器会在 Object.setPrototypeOf()中被调用。对应的反射 API 方法为Reflect.setPrototypeOf()。
isExtensible()捕获器会在 Object.isExtensible()中被调用。对应的反射 API 方法为Reflect.isExtensible()。
preventExtensions()捕获器会在 Object.preventExtensions()中被调用。对应的反射 API方法为 Reflect.preventExtensions()。
apply()捕获器会在调用函数时中被调用。对应的反射 API 方法为 Reflect.apply()。
construct()捕获器会在 new 操作符中被调用。对应的反射 API 方法为 Reflect.construct()。
```
## 9.3 代理模式
### 9.3.1 跟踪属性访问
通过get set 等，可以知道对象属性的访问时间和位置，被监控。
### 9.3.2 隐藏属性
### 9.3.3 属性验证
### 9.3.4 函数与构造函数参数验证
### 9.3.5 数据绑定与可观察式对象
```js
const userList = []; 
function emit(newValue) { 
 console.log(newValue); 
} 
const proxy = new Proxy(userList, { 
 set(target, property, value, receiver) { 
 const result = Reflect.set(...arguments); 
 if (result) { 
 emit(Reflect.get(target, property, receiver)); 
 } 
 return result; 
 } 
}); 
proxy.push('John'); 
// John 
proxy.push('Jacob'); 
// Jacob
```

# 第 10 章 函 数
## 10.1 箭头函数
```js
// 
// 使用大括号就说明包含“函数体”，可以在一个函数中包含多条语句，跟常规的函数一样。如果不使用大括号，那么箭头后面就只能有一行代码，
// 比如一个赋值操作，或者一个表达式。
// 缺点
箭头函数不能使用 arguments、super 和 new.target，也不能用作构造函数。此外，箭头函数也没有 prototype 属性。
```
## 10.2 函数名
```js
// 函数名是指向函数的指针。
// 将一个函数名赋值给一个变量，则变量相当于函数。
ECMAScript 6 的所有函数对象都会暴露一个只读的 name 属性，其中包含关于函数的信息。
function foo() {} 
let bar = function() {}; 
let baz = () => {}; 
console.log(foo.name); // foo 
console.log(bar.name); // bar 
console.log(baz.name); // baz 
console.log((() => {}).name); //（空字符串）
console.log((new Function()).name); // anonymous
```
## 10.3 理解参数
```js
// ECMAScript 函数的参数在内部表现为一个数组
arguments 对象是一个类数组对象
// 箭头函数中的参数，而只能通过定义的命名参数访问。
function foo() { 
 let bar = () => { 
 console.log(arguments[0]); // 5 
 }; 
 bar(); 
} 
foo(5);
```
## 10.4 没有重载
后边定义的会覆盖前面定义的
## 10.5 默认参数值
```js
function makeKing(name = 'Henry') { 
 return `King ${name} VIII`; 
}
// 在使用默认参数时，arguments 对象的值不反映参数的默认值，只反映传给函数的参数。
// 默认参数值并不限于原始值或对象类型，也可以使用调用函数返回的值。在调用时才会求值
let romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI']; 
let ordinality = 0; 
function getNumerals() { 
 // 每次调用后递增
 return romanNumerals[ordinality++]; 
} 
function makeKing(name = 'Henry', numerals = getNumerals()) { 
 return `King ${name} ${numerals}`; 
} 
console.log(makeKing()); // 'King Henry I'
console.log(makeKing('Louis', 'XVI')); // 'King Louis XVI' 
console.log(makeKing()); // 'King Henry II' 
console.log(makeKing()); // 'King Henry III'
// 默认参数作用域与暂时性死区
参数初始化顺序遵循“暂时性死区”规则，即前面定义的参数不能引用后面定义的.
参数也存在于自己的作用域中，它们不能引用函数体的作用域：
```
## 10.6 参数扩展与收集
扩展运算符的使用场景：函数定义中的参数列表
```js
let getSum = (a, b, c = 0) => { 
 return a + b + c; 
} 
console.log(getProduct(...[1,2])); // 2 
console.log(getProduct(...[1,2,3])); // 6 
console.log(getProduct(...[1,2,3,4])); // 6
// 收集参数的前面如果还有命名参数，则只会收集其余的参数；如果没有则会得到空数组。因为收集参数的结果可变，所以只能把它作为最后一个参数：
function getProduct(...values, lastValue) {} 
// 可以
function ignoreFirst(firstValue, ...values) { 
 console.log(values); 
}
```
## 10.7 函数声明与函数表达式
```js
// JavaScript 引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。
// 而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。
// 函数的提升
console.log(sum(10, 10)); 
let sum = function(num1, num2) { 
 return num1 + num2; 
};
```
## 10.8 函数作为值
```js
function add10(num) { 
 return num + 10; 
} 
let result1 = callSomeFunction(add10, 10); 
console.log(result1); // 20
// 也可以返回一个函数，sort函数
```
## 10.9 函数内部
```js
// arguments
function factorial(num) { 
 if (num <= 1) { 
 return 1; 
 } else { 
 return num * arguments.callee(num - 1); 
 } 
}
// this
// this谁调用就指向谁
// 箭头函数中this指的是定义箭头函数的上下文
----------------------------------------------
// caller 。这个属性引用的是调用当前函数的函数，或者如果是在全局作用域中调用的则为 null。
function outer() { 
 inner(); 
} 
function inner() { 
 console.log(inner.caller); 
 console.log(arguments.callee.caller); //严格模式下会报错
} 
outer();
---------------------------------------------
new.target
//检测函数是否使用 new 关键字调用的 new.target 属性,如果正常调用，则显示undefined,如果new关键字调用，则显示被调用的构造函数
```
## 10.10 函数属性与方法
```js
length //函数点工艺的命名参数的个数
prototypes属性
function sum(num1, num2) { 
 return num1 + num2; 
} 
function callSum1(num1, num2) { 
 return sum.apply(this, arguments); // 传入 arguments 对象
}
function callSum(num1, num2) { 
 return sum.call(this, num1, num2);  //逐个传递
}
window.color = 'red'; 
var o = { 
 color: 'blue' 
}; 
function sayColor() { 
 console.log(this.color); 
} 
let objectSayColor = sayColor.bind(o);  //将this值被绑定到传给bind()对象
objectSayColor(); // blue
```
## 10.11 函数表达式
```js
let functionName = function(arg0, arg1, arg2) { 
 // 函数体 
};
// 匿名函数(兰姆达函数)
```
## 10.12 递归
```js
const factorial = (function f(num) { 
 if (num <= 1) { 
 return 1; 
 } else { 
 return num * f(num - 1); 
 } 
});
```
## 10.13 尾调用优化
```js
代码在严格模式下执行；
外部函数的返回值是对尾调用函数的调用；
尾调用函数返回后不需要执行额外的逻辑；
尾调用函数不是引用外部函数作用域中自由变量的闭包。
```
## 10.14 闭包
```js
window.identity = 'The Window'; 
let object = { 
 identity: 'My Object', 
 getIdentityFunc() { 
 return function() { 
   return this.identity; 
  }; 
 } 
 console.log(object.getIdentityFunc()()); // 'The Window'
 object.getIdentity(); // 'My Object' 
(object.getIdentity)(); // 'My Object' 
(object.getIdentity = object.getIdentity)(); // 'The Window'
}; 
console.log(object.getIdentityFunc()()); // 'The Window'
```
## 10.15 立即调用的函数表达式
## 10.16 私有变量
```js
// 私有变量包括函数参数、局部变量，以及函数内部定义的其他函数。
// 特权方法（privileged method）是能够访问函数私有变量（及私有函数）的公有方法
function MyObject() { 
 // 私有变量和私有函数 
 let privateVariable = 10; 
 function privateFunction() { 
 return false; 
 } 
 // 特权方法，构造函数中实现
 this.publicMethod = function() { 
 privateVariable++; 
 return privateFunction(); 
 }; 
}
-------------------
 this.getName = function() { 
 return name; 
 }; 
 this.setName = function (value) { 
 name = value; 
 }; 
} 
let person = new Person('Nicholas'); 
console.log(person.getName()); // 'Nicholas' 
person.setName('Greg'); 
console.log(person.getName()); // 'Greg'
----------------------
私有变量和闭包会导致作用域链变长。
---------------------
// 模块模式
// 模块模式是在单例对象基础上加以扩展，使其通过作用域链来关联私有变量和特权方法
let singleton = function() { 
 // 私有变量和私有函数
 let privateVariable = 10; 
 function privateFunction() { 
 return false; 
 } 
 // 特权/公有方法和属性
 return { 
  publicProperty: true, 
  publicMethod() { 
  privateVariable++; 
  return privateFunction(); 
  } 
 }; 
}();
```