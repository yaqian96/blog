---
title: 字符串(知识点)
date: 2020-05-20
permalink:
categories:
  - 算法
tags:
  - null
---

# 1 反转字符串

```js
str
  .split("")
  .reverse()
  .join("");
```

# 2 括号序列

给出一个仅包含字符'(',')','{','}','['和']',的字符串，判断给出的字符串是否是合法的括号序列，括号必须以正确的顺序关闭，"()"和"()[]{}"都是合法的括号序列，但"(]"和"([)]"不合法

```js
function isValid(s) {
  if (s.length % 2) return false;
  const queue = [];
  const map = {
    "]": "[",
    ")": "(",
    "}": "{",
  };
  const left = Object.values(map);
  for (let i = 0; i < s.length; i++) {
    if (left.includes(s[i])) {
      queue.push(s[i]);
    } else {
      if (map[s[i]] !== queue.pop()) return false;
    }
  }
  return queue.length === 0;
}
```

# 3 给定一个数组，请你编写一个函数，返回该数组排序后的形式。

```js
function MySort(arr) {
  //使用方法：return arr.sort((a,b)=>a-b)
  // 二分查找，分成三部分
  if (arr.length <= 1) return arr;
  let pivotIndex = Math.floor(arr.length / 2);
  const pivot = arr[pivotIndex];
  const left = [],
    right = [];
  for (let i = 0; i < arr.length; i++) {
    if (i === pivotIndex) continue;
    if (arr[i] <= pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  return MySort(left)
    .concat(pivot)
    .concat(MySort(right));
}
```

# 4 以字符串的形式读入两个数字，编写一个函数计算它们的和，以字符串形式返回。

```js
function solve(a, b) {
  // write code here
  var res = "",
    c = 0;
  a = a.split("");
  b = b.split("");
  while (a.length || b.length || c) {
    c += ~~a.pop() + ~~b.pop();
    res = (c % 10) + res;
    c = c > 9;
  }
  return res.replace(/^0+/, "0");
}
```

# 5 回文字符串

对于一个字符串，请设计一个高效算法，计算其中最长回文子串的长度。给定字符串 A 以及它的长度 n，请返回最长回文子串的长度。

```js
export function getLongestPalindrome(A: string, n: number): number {
  let l, r;
  let max = 0;
  for (let i = 0; i < n; i++) {
    if (n - i < max / 2) break;
    l = r = i;
    while (r < n - 1 && A[r] == A[r + 1]) {
      r++;
    }
    while (l > 0 && r < n - 1 && A[l - 1] == A[r + 1]) {
      l--;
      r++;
    }
    if (r - l + 1 > max) {
      max = r - l + 1;
    }
  }
  return max;
}
```

# 6 输入一个字符串,按 `字典序`打印出该字符串中字符的所有排列。例如输入字符串 abc,则按字典序打印出由字符 a,b,c 所能排列出来的所有字符串 abc,acb,bac,bca,cab 和 cba。

```js
function Permutation(str) {
  // 递归,以每个字符串的第一个为基准，分别对字符串的前面和后边进行截取，获取最后的值
  let set = new Set();
  let addS = (pre, str) => {
    if (str.length == 0) {
      return set.add(pre + str);
    }
    for (let i = 0; i < str.length; i++) {
      addS(pre + str[i], str.slice(0, i) + str.slice(i + 1));
    }
  };
  addS("", str);
  console.log(set);
  return Array.from(set);
}
```

# 7 判断回文

```js
function judge(str) {
  // 中间的地方进行循环，依次判断两边
  const len = str.length;
  const mid = parseInt((len - 1) / 2);

  for (let i = 0; i <= mid; i++) {
    if (str[i] !== str[len - 1 - i]) {
      return false;
    }
  }

  return true;
}
```

# 8 现在有一个只包含数字的字符串，将该字符串转化成 IP 地址的形式，返回所有可能的情况。

例如：
给出的字符串为"25525522135",
返回["255.255.22.135", "255.255.221.35"]. (顺序没有关系)

```js
// 实现思路：
//ip地址：1、ip地址由四个整数组成；
//2、每个整数的范围是[0,255]；
//3、四个整数通过逗号分隔符连接
//4、每个整数除了它本身是0的情况之外，不能以0开头
let arr = [];
getSplit(4, s, []);
function getSplit(nums, leftStr, tmp) {
  if (nums === 0 && leftStr === "") {
    arr.push(tmp.join("."));
    return;
  }
  if ((nums === 0 && leftStr !== "") || (nums !== 0 && leftStr === "")) {
    return;
  }
  var max = Math.min(3, leftStr.length);
  for (var i = 1; i <= max; i++) {
    var num = leftStr.slice(0, i);
    if (num > 255 || (num[0] === "0" && num.length !== 1)) {
      break;
    }
    tmp.push(leftStr.slice(0, i));
    getSplit(nums - 1, leftStr.slice(i), tmp);
    tmp.pop();
  }
}
return arr;
```

# 9 最长的括号子串的长度

```js
function longestValidParentheses(s) {
  let res = 0;
  let stack = [-1];
  for (let i = 0; i < s.length; i++) {
    if (s[i] === "(") {
      stack.push(i);
    } else {
      stack.pop();
      if (stack.length) {
        res = Math.max(res, i - stack[stack.length - 1]);
      } else {
        stack.push(i);
      }
    }
  }
  return res;
}
```

# 10 编写一个函数来查找字符串数组中的最长公共前缀。

```js
function longestCommonPrefix(strs) {
  if (!strs.length) return "";
  if (strs.length === 1) return strs[0];
  strs.sort();
  let first = strs[0];
  let end = strs[strs.length - 1];
  let res = "";
  for (let i = 0; i < first.length; i++) {
    if (first[i] === end[i]) {
      res += first[i];
    } else {
      break;
    }
  }
  return res;
}
```

# 11 大数相乘

以字符串的形式读入两个数字，编写一个函数计算它们的乘积，以字符串形式返回。

```js
function solve(s, t) {
  // write code here
  if (s.length || t.length) {
    s = BigInt(s);
    t = BigInt(t);
    return "" + s * t;
  }
}
```

# 12 正则表达式匹配

请实现一个函数用来匹配包括'.'和'_'的正则表达式。模式中的字符'.'表示任意一个字符，而'_'表示它前面的字符可以出现任意次（包含 0 次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab\*a"均不匹配

```js
function match(str, pattern) {
  return checkMatch(str, 0, pattern, 0);
}
function checkMatch(s, i, p, j) {
  if (j === p.length && i !== s.length) return false;
  if (j === p.length && i === s.length) return true;
  if (p[j + 1] !== "*") {
    if (s[i] === p[j] || p[j] === ".") {
      return checkMatch(s, i + 1, p, j + 1);
    } else {
      return false;
    }
  } else {
    if (s[i] !== p[j] && p[j] !== ".") {
      return checkMatch(s, i, p, j + 2);
    } else if (s[i] === p[j] || (p[j] === "." && i !== s.length)) {
      return (
        checkMatch(s, i + 1, p, j) ||
        checkMatch(s, i + 1, p, j + 2) ||
        checkMatch(s, i, p, j + 2)
      );
    } else if (p[j] === "." && s.length === 0) return true;
  }
  return false;
}
```

# 13 通配符匹配，请实现支持'?'and'_'.的通配符模式匹配,'?' 可以匹配任何单个字符。'_' 可以匹配任何字符序列（包括空序列）。

```js
/**
 *
 * @param s string字符串
 * @param p string字符串
 * @return bool布尔型
 */
function isMatch(s, p) {
  let arr1 = s.split("");
  let arr2 = p.split("");
  let i = 0,
    j = 0,
    star = 0,
    ss = 0;
  while (arr1[i]) {
    if (arr2[j] == "?" || arr1[i] == arr2[j]) {
      i++;
      j++;
      continue;
    }
    if (arr2[j] == "*") {
      star = ++j;
      ss = i;
      continue;
    }
    if (star) {
      j = star;
      i = ++ss;
      continue;
    }
    return false;
  }
  while (arr2[j] == "*") j++;
  return !arr2[j];
}
```

# 14 最小编辑代价

```js
//给定两个字符串str1和str2，再给定三个整数ic，dc和rc，分别代表插入、删除和替换一个字符的代价，请输出将str1编辑成str2的最小代价。
/**
 * min edit cost
 * @param str1 string字符串 the string
 * @param str2 string字符串 the string
 * @param ic int整型 insert cost
 * @param dc int整型 delete cost
 * @param rc int整型 replace cost
 * @return int整型
 */
function minEditCost(str1, str2, ic, dc, rc) {
  // write code here
  const len1 = str1.length,
    len2 = str2.length;
  const dp = new Array(len2 + 1).fill(0);
  for (let i = 1; i <= len2; i++) dp[i] = i * ic;
  for (let i = 1; i <= len1; i++) {
    let prev = dp[0];
    dp[0] = i * dc;
    for (let j = 1; j <= len2; j++) {
      const tmp = dp[j];
      if (str1[i - 1] === str2[j - 1]) dp[j] = prev;
      else dp[j] = Math.min(prev + rc, dp[j - 1] + ic, tmp + dc);
      prev = tmp;
    }
  }
  return dp[len2];
}
```

# 15 将字符串转换为整数

```js
// 考虑最大值和最小值的情况
/**
 *
 * @param str string字符串
 * @return int整型
 */
function atoi(str) {
  if (!str) return 0;
  const max = Math.pow(2, 31) - 1;
  const min = -Math.pow(2, 31);
  if (str.length) {
    let res = parseInt(str);
    if (res > max) return max;
    if (res < min) return min;
    return res;
  }
}
```

# 16 字符串变形

```js
// 对于一个给定的字符串，我们需要在线性(也就是O(n))的时间里对它做一些变形。首先这个字符串中包含着一些空格，就像"Hello World"一样，然后我们要做的是把着个字符串中由空格隔开的单词反序，同时反转每个字符的大小写。比如"Hello World"变形后就变成了"wORLD hELLO"。
function trans(s, n) {
  var arr1 = s.split(" ");
  var arr2 = arr1.reverse();
  var str = arr2.join(" ");
  // 将字符串拆开成一个一个小的字符进行替换
  var arr = str.split("");
  for (var i = 0; i < arr.length; i++) {
    if (/[a-z]/g.test(arr[i])) {
      arr[i] = arr[i].toUpperCase();
    } else if (/[A-Z]/g.test(arr[i])) {
      arr[i] = arr[i].toLowerCase();
    }
  }
  str = arr.join("");
  return str;
}
```

# 17 最小覆盖子串
```js
// 给出两个字符串 SS 和 TT，要求在O(n)O(n)的时间复杂度内在 SS 中找出最短的包含 TT 中所有字符的子串。
// 例如：
// S ="XDOYEZODEYXNZ"
// T ="XYZ"
// 找出的最短子串为"YXNZ"
// 注意：
// 如果 SS 中没有包含 TT 中所有字符的子串，返回空字符串 “”；
// 满足条件的子串可能有很多，但是题目保证满足条件的最短的子串唯一。
---------------(
  // 解题思路：双指针和窗口值，一直不停地变换窗口，实时改变。map中的数字始终保持3个。
  /**
   *
   * @param S string字符串
   * @param T string字符串
   * @return string字符串
   */
  function minWindow(S, T) {
    let map = {},
      head = 0,
      len = Infinity,
      start = 0,
      end = 0,
      count = T.length;

    for (const c of T) {
      if (map[c] === undefined) map[c] = 1;
      else map[c] += 1;
    }
    console.log(map); //{ X: 1, Y: 1, Z: 1 }用map记录次数

    while (end < S.length) {
      if (map[S[end]] !== undefined) {
        if (map[S[end]] > 0) count--;
        map[S[end]]--;
      }
      end++; //添加end

      while (count == 0) {
        if (end - start < len) {
          head = start;
          len = end - start;
        } //满足条件，更新
        if (map[S[start]] !== undefined) {
          if (map[S[start]] == 0) count++;
          map[S[start]]++;
        } //往前挪动start
        start++;
      }
    }

    return len === Infinity ? "" : S.slice(head, head + len);
  }
);
```
# 18 最长重复字符串
```js
//一个重复字符串是由两个相同的字符串首尾拼接而成，例如abcabc便是长度为6的一个重复字符串，而abcba则不存在重复字符串。
-----
// 从中间算起，总和是5,0与2 1与3,每次相等max加1，如果最大值是长度的一半，则*2
function solve( a ) {
    let len = a.length; // 5
    for (let i = Math.floor(len/2); i >= 0; i--) { // i = 2; i >=0; i++
        let max = 0;
        for (let j = 0; j + i < len; j++) { // j =0; j + i < 5; j++
            if (a[j] === a[j + i]) { // a[0]=== a[0 + 2]
                max++;
            } else {
                max = 0;
            }
            if (max === i) {
                return max * 2;
            }
        }
    }
    return 0;
}
```
# 19 第一个出现一次的字符
```js
// 在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）
function FirstNotRepeatingChar(str)
{
    for(var i = 0;i<str.length;i++){
        if(str.indexOf(str[i]) == str.lastIndexOf(str[i])) return i
        // 判断第一次出现的下标和最后一次出现的下标相等，则返回下标
    }
    return -1
}
```
# 20 旋转字符串
```js
// 字符串旋转:
// 给定两字符串A和B，如果能将A从中间某个位置分割为左右两部分字符串（都不为空串），并将左边的字符串移动到右边字符串后面组成新的字符串可以变为字符串B时返回true。
// 例如：如果A=‘youzan’，B=‘zanyou’，A按‘you’‘zan’切割换位后得到‘zanyou’和B相同返回true。
function solve( A ,  B ) {
  if(A.length < 2 || B.length < 2 || A.length !== B.length)return false
  return (A + A).includes(B)
  // 将A的值拼接到后边，如果B中包含B，则可以相同。
}
```
# 21 循环右移
```js
// 有一个二进制数的字符串，想把字符串循环右移k位，然后得到一个新的二进制数，求这个数的十进制值是多少。给定一个二进制字符串str和循环位移位数k，返回循环后的二进制数的十进制值
// 思路：右移K位将字符串分为两部分，右移的k位挪到前边，组成新的二进制，循环计算值
function rotateRight( str ,  k ) {
    // write code here
    k=k%str.length
    let left=str.substr(0,str.length-k);
    let right=str.substr(str.length-k,k);
    let newStr=right+left;
    newStr= newStr.split('')
    let res=0, x=1;
    for(let i=newStr.length-1;i>=0;i--){
        res += (Number(newStr[i]))*x;
         x *= 2;
    }
     return res;
}
```