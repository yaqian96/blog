---
title: nextTick
date: 2021-08-02
categories:
  - vue
tags:
  - vue
---
源码位置：src/core/util/next-tick.js
本质调用微任务队列。
```js
export function nextTick (cb?: Function, ctx?: Object) {
  let _resolve;
  // 1. 有回调函数，将回调函数绑定上下文，如果没有则resolve
  callbacks.push(() => {
    if (cb) {
      try {
        cb.call(ctx)
      } catch (e) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  // 2. 将pending设置为true
  if (!pending) {
    pending = true
    timerFunc()
    // timerFunc: 优先使用微任务，再使用宏任务。主要根据不同的兼容性问题。
    // 1. 如果支持promise,则采用promise.then(callbacks)
    // 2. 如果支持MutationObserver，则new MutationObserver(flushCallbacks)
    // 3. 如果支持setImmediate，则 setImmediate(flushCallbacks)
    // 4. setTimeout(flushCallbacks, 0)
    `MutationObserver`:DOM 被修改时异步执行回调,可观察整个文档、DOM树的一部分、或某个元素。
    let observer = new MutationObserver( 
    (mutationRecords) => console.log(mutationRecords));
    )
    // 1. 终止被观测的元素
    setTimeout(() => { 
    observer.disconnect(); 
    document.body.className = 'bar'; 
    }, 0);
    // 2. MutationObserverInit 与观察范围    属性变化attributes   子节点变化subtree  attributeFilter可写入观察的数组    attributeOldValue是否记录变化之前的属性  characterData修改字符属性   characterDataOldValue childList
    `每次变化的信息（由观察者实例决定）会保存在 MutationRecord实例中，然后添加到记录队列。这个队列对每个 MutationObserver 实例都是唯一的，是所有DOM变化事件的有序列表。仅当之前没有已排期的微任务回调时（队列中微任务长度为 0），才会将观察者注册的回调（在初始化 MutationObserver 时传入）作为微任务调度到任务队列上。`
    // 3. takeRecords()方法：清空任务队列
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(resolve => {
      _resolve = resolve
    })
  }
}
```