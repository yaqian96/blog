---
title: vue源码(生命周期)
date: 2021-07-20
categories:
  - vue源码
tags:
  - vue源码
---
# 初始化阶段 new Vue()-initEvent&initLifecycle--beforeCreate--initInjectctions&initState--created
beforeCreate() created()
  1. new Vue()
   创建一个vue实例
   ```js
   function Vue (options) {
      if (process.env.NODE_ENV !== 'production' &&
        !(this instanceof Vue)
      ) {
        warn('Vue is a constructor and should be called with the `new` keyword')
      }
      this._init(options)
    }
    <!-- 源码位置：src/core/instance/init.js -->
    export function initMixin (Vue) {
      Vue.prototype._init = function (options) {
        const vm = this
        <!--  initGlobalAPI(Vue)中,使用extends内置扩展,内置的扩展元素有<keep-alive>、<transition> 和<transition-group> 组件-->
        vm.$options = mergeOptions(
            resolveConstructorOptions(vm.constructor),
            options || {},
            vm
        )
        <!-- 1. 将实例传给变量vm  2. 合并options  3. 实例初始化属性 4. 通过用户传入的el，调用vm.$mount()-->
        vm._self = vm
        initLifecycle(vm)       // 初始化生命周期
        initEvents(vm)        // 初始化事件
        initRender(vm)         // 初始化渲染
        callHook(vm, 'beforeCreate')  // 调用生命周期钩子函数
        initInjections(vm)   //初始化injections
        initState(vm)    // 初始化props,methods,data,computed,watch
        initProvide(vm) // 初始化 provide
        callHook(vm, 'created')  // 调用生命周期钩子函数
        if (vm.$options.el) {
          vm.$mount(vm.$options.el)
        }
      }
    }
   ```
   ```js
     <!-- 生命周期钩子函数的合并策略 -->
     /**
      * Hooks and props are merged as arrays.
      */
      export const LIFECYCLE_HOOKS = [
        'beforeCreate',
        'created',
        'beforeMount',
        'mounted',
        'beforeUpdate',
        'updated',
        'beforeDestroy',
        'destroyed',
        'activated',
        'deactivated',
        'errorCaptured'
      ]
      function mergeHook (parentVal,childVal):  {
        return childVal
          ? parentVal
            ? parentVal.concat(childVal)
            : Array.isArray(childVal)
              ? childVal
              : [childVal]
          : parentVal
      }

      LIFECYCLE_HOOKS.forEach(hook => {
        strats[hook] = mergeHook
      })
   ```
   ```js
    //callHook函数如何触发钩子函数
    <!-- 位置：src/core/instance/lifecycle.js -->
    export function callHook (vm: Component, hook: string) {
      const handlers = vm.$options[hook]
      if (handlers) {
        for (let i = 0, j = handlers.length; i < j; i++) {
          try {
            handlers[i].call(vm)
          } catch (e) {
            handleError(e, vm, `${hook} hook`)
          }
        }
      }
    }
   ```
  2. initLifecycle函数分析
  ```js
  <!-- src/core/instance/lifecycle.js -->
  export function initLifecycle (vm: Component) {
    const options = vm.$options
    <!-- 挂载$parent -->
    let parent = options.parent
    if (parent && !options.abstract) {
      while (parent.$options.abstract && parent.$parent) {
        parent = parent.$parent
      }
      parent.$children.push(vm)
    }
      vm.$parent = parent
      vm.$root = parent ? parent.$root : vm
      vm.$children = []
      vm.$refs = {}
      vm._watcher = null
      vm._inactive = null
      vm._directInactive = false
      vm._isMounted = false
      vm._isDestroyed = false
      vm._isBeingDestroyed = false
    }
  ```
  3. initEvents函数分析
  ```js
  <!-- src/compiler/helpers.js -->
  export function addHandler (el,name,value,modifiers) {
      modifiers = modifiers || emptyObject
      // check capture modifier 判断是否有capture修饰符
      if (modifiers.capture) {
        delete modifiers.capture
        name = '!' + name // 给事件名前加'!'用以标记capture修饰符
      }
      // 判断是否有once修饰符
      if (modifiers.once) {
        delete modifiers.once
        name = '~' + name // 给事件名前加'~'用以标记once修饰符
      }
      // 判断是否有passive修饰符
      if (modifiers.passive) {
        delete modifiers.passive
        name = '&' + name // 给事件名前加'&'用以标记passive修饰符
      }

      let events
      if (modifiers.native) {
        delete modifiers.native
        events = el.nativeEvents || (el.nativeEvents = {})
      } else {
        events = el.events || (el.events = {})
      }

      const newHandler: any = {
        value: value.trim()
      }
      if (modifiers !== emptyObject) {
        newHandler.modifiers = modifiers
      }

      const handlers = events[name]
      if (Array.isArray(handlers)) {
        handlers.push(newHandler)
      } else if (handlers) {
        events[name] = [handlers, newHandler]
      } else {
        events[name] = newHandler
      }
      el.plain = false
    }
    <!-- 实际上初始化的是父组件在模板中使用v-on或@注册的监听子组件内触发的事件。 -->
  ```
  ```js
  export function initEvents (vm: Component) {
    vm._events = Object.create(null)
    // init parent attached events
    const listeners = vm.$options._parentListeners
    if (listeners) {
      updateComponentListeners(vm, listeners)
    }
  }
  export function updateComponentListeners (
    vm: Component,
    listeners: Object,
    oldListeners: ?Object
  ) {
    target = vm
    <!-- updateListeners函数的作用是对比listeners和oldListeners的不同，并调用参数中提供的add和remove进行相应的注册事件和卸载事件 -->
    <!-- normalizeEvent函数是反向操作，根据事件名前面的不同标识反向解析出该事件所带的何种修饰符 -->
    updateListeners(listeners, oldListeners || {}, add, remove, vm)
    target = undefined
  }

  function add (event, fn, once) {
    if (once) {
      target.$once(event, fn)
    } else {
      target.$on(event, fn)
    }
  }

  function remove (event, fn) {
    target.$off(event, fn)
  }
  ```
  4. initInjection函数分析
  ```js
  <!-- 它们的作用是：允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。 -->
  export function initInjections (vm: Component) {
    <!-- 调用resolveInject把inject选项中的数据转化成键值对的形式赋给result -->
    const result = resolveInject(vm.$options.inject, vm)
    if (result) {
      toggleObserving(false)
      <!-- 循环遍历将其变成可响应 -->
      Object.keys(result).forEach(key => {
        defineReactive(vm, key, result[key])
      }
      toggleObserving(true)
      }
    }
    <!-- provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。 -->
    export let shouldObserve: boolean = true
    export function toggleObserving (value: boolean) {
      shouldObserve = value
    }
    <!-- 将不同写法的进行集中处理 -->
  function normalizeInject (options: Object, vm: ?Component) {
    const inject = options.inject
    if (!inject) return
    const normalized = options.inject = {}
    if (Array.isArray(inject)) {
      for (let i = 0; i < inject.length; i++) {
        normalized[inject[i]] = { from: inject[i] }
      }
    } else if (isPlainObject(inject)) {
      for (const key in inject) {
        const val = inject[key]
        normalized[key] = isPlainObject(val)
          ? extend({ from: key }, val)
          : { from: val }
      }
    } else if (process.env.NODE_ENV !== 'production') {
      warn(
        `Invalid value for option "inject": expected an Array or an Object, ` +
        `but got ${toRawType(inject)}.`,
        vm
      )
    }
  }
  ```
  5. initState函数分析
  ```js
  <!-- src/core/instance/state.js -->
  export function initState (vm: Component) {
    vm._watchers = []
    <!-- 2.0版本之后，对组件进行拦截侦测_watchers -->
    const opts = vm.$options
    if (opts.props) initProps(vm, opts.props)
    if (opts.methods) initMethods(vm, opts.methods)
    if (opts.data) {
      initData(vm)
    } else {
      observe(vm._data = {}, true /* asRootData */)
    }
    if (opts.computed) initComputed(vm, opts.computed)
    if (opts.watch && opts.watch !== nativeWatch) {
      initWatch(vm, opts.watch)
    }
  }
  ```
  ```js
  function initProps (vm: Component, propsOptions: Object) {
    const propsData = vm.$options.propsData || {}
    const props = vm._props = {}
    const keys = vm.$options._propKeys = []
    const isRoot = !vm.$parent
    if (!isRoot) {
      toggleObserving(false)
    }
    for (const key in propsOptions) {
      keys.push(key)
      const value = validateProp(key, propsOptions, propsData, vm)
      if (process.env.NODE_ENV !== 'production') {
        const hyphenatedKey = hyphenate(key)
        if (isReservedAttribute(hyphenatedKey) ||
            config.isReservedAttr(hyphenatedKey)) {
          warn(
            `"${hyphenatedKey}" is a reserved attribute and cannot be used as component prop.`,
            vm
          )
        }
        defineReactive(props, key, value, () => {
          if (vm.$parent && !isUpdatingChildComponent) {
            warn(
              `Avoid mutating a prop directly since the value will be ` +
              `overwritten whenever the parent component re-renders. ` +
              `Instead, use a data or computed property based on the prop's ` +
              `value. Prop being mutated: "${key}"`,
              vm
            )
          }
        })
      } else {
        defineReactive(props, key, value)
      }
      if (!(key in vm)) {
        proxy(vm, `_props`, key)
      }
    }
    toggleObserving(true)
  }
  ```
  ```js
    function initMethods (vm, methods) {
      const props = vm.$options.props
      for (const key in methods) {
        if (process.env.NODE_ENV !== 'production') {
          if (methods[key] == null) {
            warn(
              `Method "${key}" has an undefined value in the component definition. ` +
              `Did you reference the function correctly?`,
              vm
            )
          }
          if (props && hasOwn(props, key)) {
            warn(
              `Method "${key}" has already been defined as a prop.`,
              vm
            )
          }
          if ((key in vm) && isReserved(key)) {
            warn(
              `Method "${key}" conflicts with an existing Vue instance method. ` +
              `Avoid defining component methods that start with _ or $.`
            )
          }
        }
        vm[key] = methods[key] == null ? noop : bind(methods[key], vm)
      }
    }
  ```
  ```js
  function initData (vm) {
    let data = vm.$options.data
    data = vm._data = typeof data === 'function'
        ? getData(data, vm)
    : data || {}
    if (!isPlainObject(data)) {
        data = {}
        process.env.NODE_ENV !== 'production' && warn(
            'data functions should return an object:\n' +
            'https://vuejs.org/v2/guide/components.html##data-Must-Be-a-Function',
            vm
        )
    }
    // proxy data on instance
    const keys = Object.keys(data)
    const props = vm.$options.props
    const methods = vm.$options.methods
    let i = keys.length
    while (i--) {
        const key = keys[i]
        if (process.env.NODE_ENV !== 'production') {
            if (methods && hasOwn(methods, key)) {
                warn(
                    `Method "${key}" has already been defined as a data property.`,
                    vm
                )
            }
        }
        if (props && hasOwn(props, key)) {
            process.env.NODE_ENV !== 'production' && warn(
                `The data property "${key}" is already declared as a prop. ` +
                `Use prop default value instead.`,
                vm
            )
        } else if (!isReserved(key)) {
            proxy(vm, `_data`, key)
        }
    }
    // observe data
    observe(data, true /* asRootData */)
  }
  ```
  ```js
  function initComputed (vm: Component, computed: Object) {
    const watchers = vm._computedWatchers = Object.create(null)
    const isSSR = isServerRendering()

    for (const key in computed) {
        const userDef = computed[key]
        const getter = typeof userDef === 'function' ? userDef : userDef.get
        if (process.env.NODE_ENV !== 'production' && getter == null) {
            warn(
                `Getter is missing for computed property "${key}".`,
                vm
            )
        }
        if (!isSSR) {
            // create internal watcher for the computed property.
            watchers[key] = new Watcher(
                vm,
                getter || noop,
                noop,
                computedWatcherOptions
            )
        }
        if (!(key in vm)) {
            defineComputed(vm, key, userDef)
        } else if (process.env.NODE_ENV !== 'production') {
            if (key in vm.$data) {
                warn(`The computed property "${key}" is already defined in data.`, vm)
            } else if (vm.$options.props && key in vm.$options.props) {
                warn(`The computed property "${key}" is already defined as a prop.`, vm)
            }
        }
    }
  }
  ```
  ```js
  function initWatch (vm, watch) {
    for (const key in watch) {
      const handler = watch[key]
      if (Array.isArray(handler)) {
        for (let i = 0; i < handler.length; i++) {
          createWatcher(vm, key, handler[i])
        }
      } else {
        createWatcher(vm, key, handler)
      }
    }
  }
  ```
# 模板编译阶段
```js
// 需要编译器的版本
new Vue({
  template: '<div>{{ hi }}</div>'
})
// 不需要编译器
new Vue({
  render (h) {
    return h('div', this.hi)
  }
})
```
```js
// 模板编译阶段分析
// 运行时的版本的$mount
Vue.prototype.$mount = function (el,hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};
// 完整版本的
var mount = Vue.prototype.$mount;   //缓存的是运行版本的$mount方法
Vue.prototype.$mount = function (el,hydrating) {
  // 省略获取模板及编译代码
  el = el && query(el);
  if (el === document.body || el === document.documentElement) {
    warn(
      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
    );
    return this
  }

  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      if (typeof template === 'string') {
          if (template.charAt(0) === '#') {
            template = idToTemplate(template);
            /* istanbul ignore if */
            if (!template) {
              warn(
                ("Template element not found or is empty: " + (options.template)),
                this
              );
            }
          }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        {
          warn('invalid template option:' + template, this);
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      if (config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        outputSourceRange: "development" !== 'production',
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      if (config.performance && mark) {
        mark('compile end');
        measure(("vue " + (this._name) + " compile"), 'compile', 'compile end');
      }
    }
  }
  return mount.call(this, el, hydrating)
}
```
# 挂载阶段
beforeMount() mounted()
beforeUpdate() updated()
```js
export function mountComponent (vm,el,hydrating) {
    vm.$el = el
    if (!vm.$options.render) {
        vm.$options.render = createEmptyVNode
    }
    callHook(vm, 'beforeMount')
    // updateComponent函数，将最新的模板内容渲染到视图页面中
    let updateComponent
    updateComponent = () => {
        vm._update(vm._render(), hydrating)
    }
    // 对数据进行模板中的数据进行监控
    new Watcher(vm, updateComponent, noop, {
        before () {
            if (vm._isMounted) {
                callHook(vm, 'beforeUpdate')
            }
        }
    }, true /* isRenderWatcher */)
    hydrating = false
    // 最后才是mounted
    if (vm.$vnode == null) {
        vm._isMounted = true
        callHook(vm, 'mounted')
    }
    return vm
}
```
# 销毁阶段
beforeDestory() destoryed()
```js
Vue.prototype.$destroy = function () {
  const vm: Component = this
  if (vm._isBeingDestroyed) {
    return
  }
  callHook(vm, 'beforeDestroy')
  vm._isBeingDestroyed = true
  // remove self from parent
  const parent = vm.$parent
  if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
    remove(parent.$children, vm)
  }
  // teardown watchers
  if (vm._watcher) {
    vm._watcher.teardown()
  }
  let i = vm._watchers.length
  while (i--) {
    vm._watchers[i].teardown()
  }
  // remove reference from data ob
  // frozen object may not have observer.
  if (vm._data.__ob__) {
    vm._data.__ob__.vmCount--
  }
  // call the last hook...
  vm._isDestroyed = true
  // invoke destroy hooks on current rendered tree
  vm.__patch__(vm._vnode, null)
  // fire destroyed hook
  callHook(vm, 'destroyed')
  // 移除所有的监听
  vm.$off()
  // remove __vue__ reference
  if (vm.$el) {
    vm.$el.__vue__ = null
  }
  // release circular reference (##6759)
  if (vm.$vnode) {
    vm.$vnode.parent = null
  }
}
```