---
title: ECMAScript
date: 2021-07-27
categories:
  - react
tags:
  -
---

# ES6 的新知识

```js
1. Set  WeakSet
它类似于数组，但是成员的值都是唯一的，没有重复的值。Set本身是一个构造函数，用来生成Set数据结构。
   const s=new Set();
   s.add()
   s.size 判断长度
   delete(value) ：删除某个值，返回一个布尔值，表示删除是否成功。
   has(value) ：返回一个布尔值，表示该值是否为 Set 的成员。
   clear() ：清除所有成员，没有返回值。
   遍历操作：keys() values() entries() forEach()
WeakSet的区别：
第一个：WeakSet的成员只能是对象，而不能是其他的值。
第二个：WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象。那么垃圾回收机制会自动会输该对象所占用的额内存，不考虑该对象还存在与WeakSet之中。
   size  没有size属性，没有办法遍历它的成员。无法清空
   用处：存储DOM节点
2. Map、WeakMap
它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。没有 entries、keys 和 values 等方法
    size
    set(key, value)
    get(key)
    has(key)
    delete(key)
    clear()
    遍历操作：keys() values() entries() forEach()
WeakSet:
唯一的区别是它只接受对象作为键名（ null 除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。没有 entries、keys 和 values 等方法
3. 箭头函数
   1. 不能当做构造函数
   2. 没有arguments
   3. 没有super
   4. 没有原型
   5. 没有new.target
   6. 没有this
   7. 不能定义生成器函数
4. let const var的区别
   1. let const不允许在相同作用域内，重复声明同一个变量
   2. const声明一个只读的常量，常量的值就不能改变，但是针对对象，就是可改变的。
5. for...of
   使用的范围：数组、Set 和 Map 结构、某些类似数组的对象（比如 arguments 对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。
   普通对象，不能直接使用for..of
6. proxy
7. es6 以及相关的模块化理解
AMD(异步模块定义)===>require.js===>用于浏览器端
CommonJS===>node===>用于服务器端
CMD模块定义规范===>Sea.js
 CommonJS与ES6 module区别：
   1. CommonJS是值的拷贝，ES6是值的引用
   2. CommonJS是运行时加载，ES6是编译时输出接口
   3. CommomJS是require()同步加载模块，ES6的import是异步加载
  ES6 module
  1. 'import export'
  2. 采用单例模式，重复的模块只执行一次
  3. 自动采用严格模式，模块之中，顶层的 this 关键字返回 undefined ，而不是指向 window 。
8. class
  1. 在class中声明方法其实就是声明在原型上，类本身就是指向构造函数，类里面定义的方法都是不可枚举的。this指向类的实例。
  class Person {
    // 静态属性
    static x = 0;
    constructor() {
      this._x=0;//私有属性
			this.y=0;//公有属性
    }
    toString(){
      console.log('parent toString method');
    }
    //私有方法
    _printName(){
      this.toString()
    }
    * add(){
      for(let i =0;i<10;i++) {
        yield i;
      }
    }
  }
  2. class的继承
    class ColorPoint extends Point {}
    1. ES5的继承，实质是先创造子类的实例对象 this ，然后再将父类的方法添加到 this 上面（ Parent.apply(this) ）。ES6的继承机制完全不同，实质是先创造父类的实例对象 this （所以必须先调用 super 方法），然后再用子类的构造函数修改 this 。
    2.
    class A { }
    class B extends A { }
    B.__proto__ === A // true
    B.prototype.__proto__ === A.prototype // true
    3. Object.getPrototypeOf 方法可以用来从子类上获取父类。
  3. super
    1. 既可以当作函数使用，也可以当作对象使用.
    2. 通过 super 调用父类的方法时， super 会绑定子类的 this 。
    3. 如果 super 作为对象，用在静态方法之中，这时 super 将指向父类，而不是父类的原型对象。
9. 函数式编程
   1. 柯里化
   2. 函数合成
   3. 参数倒置（flip）:改变函数前两个参数的顺序。
   4. 执行边界（until）指的是函数执行到满足条件为止
   5. 队列操作 head last tail init
   6. 合并操作 concat concatMap
   7. 配对操作 zip zipWith
10. Reflect
    可以操作对象的API
    Reflect.apply(target,thisArg,args)
    Reflect.construct(target,args)
    Reflect.get(target,name,receiver)
    Reflect.set(target,name,value,receiver)
    Reflect.defineProperty(target,name,desc)
    Reflect.deleteProperty(target,name)
    Reflect.has(target,name)
    Reflect.ownKeys(target)
    Reflect.isExtensible(target)
    Reflect.preventExtensions(target)
    Reflect.getOwnPropertyDescriptor(target, name)
    Reflect.getPrototypeOf(target)
    Reflect.setPrototypeOf(target, prototype)
11. promise
   1. Pending （进行中）、 Resolved （已完成，又称 Fulfilled）和 Rejected （已失败）。
   2. 对象的状态不受外界影响。
   3. 一旦状态改变，就不会再变，任何时候都可以得到这个结果
   4. 缺点：无法取消promise,一旦新建它就会立即执行，无法中途取消
   Promise对象是一个构造函数。
    var promise = new Promise(function(resolve, reject) {
    // ... some code
    if (/* 异步操作成功 */){
    resolve(value); //从Pending变为Resolved
    } else {
    reject(error); //从Pending变为Rejected
    }
    });
    promise.then(function(value) {
    // success   resolved的回调函数
    }, function(error) {
    // failure  rejected的回调函数
    });
    API
    Promise.prototype.then()
    Promise.prototype.catch() //.then(null, rejection) 的别名，
    Promise.all()  //只有所有的promise状态都变成 fulfilled,状态才会变成 fulfilled,并返回数组。如果有一个为rejected,则返回第一个rejected的值
    Promise.race() //之中有一个实例率先改变状态， p 的状态就跟着改变
    Promise.resolve()
    1. 参数是一个Promise实例  //返回这个实例
    2. 参数是一个 thenable 对象 //会立即执行thenable对象的then方法
    3. 参数不是具有 then 方法的对象，或根本就不是对象 //返回一个新的promise对象，状态为resolved
    4. 不带有任何参数  //返回一个 Resolved 状态的Promise对象
    Promise.reject() //会原封不动地作为 reject 的理由，变成后续方法的参数
    Promise.try()   //不知道或者不想区分，函数 f 是同步函数还是异步操作，但是想用 Promise 来处理它
    done() //于回调链的尾端，保证抛出任何可能出现的错误
    finally() //不管Promise对象最后状态如何，都会执行的操作
  使用场景：
  1. axios、fetch中的promise
  2. 加载图片
  `如何在外部修改promise的状态`
  解决方法：在promise外部通过地址引用的方式进行改变promise内部状态是可以实现的。
  `JS实现一个带并发限制的异步调度器Scheduler，保证同时运行的任务最多有两个，`
  const timeout = (time) => new Promise(resolve => {
    setTimeout(resolve, time)
  });
  class Scheduler {
      constructor() {
          this.awaitArr = [];
          this.count = 0;
      }
      async add(promiseCreator) {
          if (this.count >= 2) {
              await new Promise(resolve => {
                  this.awaitArr.push(resolve);
              });
          }
          this.count++;
          const res = await promiseCreator();
          this.count--;

          if (this.awaitArr.length) {
              this.awaitArr.shift()();
          }
          return res;
      }
  }
  const scheduler = new Scheduler()
  const addTask = (time, order) => {
      scheduler.add(() => timeout(time))
          .then(() => console.log(order))
  }
  addTask(1000, '1000')
  addTask(500, '500')
  addTask(400, '400')
  addTask(300, '300')
  // 500 400 1000 300
12. async
   1. async 表示函数里有异步操作,await 命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）
   2. async返回的值是promise
   3. async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数
```

# ES7

```JS
1. Array.includes() 方法
2. 求幂运算符
```

# es8

```js
1. Async/Await
2. Object.values()，Object.entries()
3. String.padStart(targetLength,[padString]) String.padEnd(targetLength,[padString])
4. Object.getOwnPropertyDescriptors()
```

# es9

```js
1. for await of
可以用来遍历具有 Symbol.asyncIterator 方法的数据结构，也就是异步迭代器，且会等待前一个成员的状态改变后才会遍历到下一个成员，相当于 async 函数内部的 await。
2. 扩展运算符
3. Promise.prototype.finally()
4. 新的正则表达式特性
s (dotAll) 标志
命名捕获组
Lookbehind 后行断言
Unicode 属性转义
```

# es10

```js
1. Array.prototype.flat()
2. Array.prototype.flatMap()
3. Object.fromEntries() //与entries相反
4. String.trimStart 和 String.trimEnd
5. try…catch
try {
  console.log('Foobar')
} catch {
  console.error('Bar')
}

6. Symbol.prototype.description
Symbol('desc').description; // "desc"
7. Function.prototype.toString()
function sum(a, b) {
  return a + b;
}
console.log(sum.toString());
// function sum(a, b) {
// return a + b;
// }
```

# ES11

```JS
1. String 的 matchAll 方法
2. 动态导入语句 import()
if (xx) {
  const module = import('/module')
}
3. import.meta
<script type="module" src="my-module.mjs"></script>
console.log(import.meta); // { url: "file:///home/user/my-module.mjs" }

4. export * as ns from 'module'

5. Promise.allSettled

6. 新增数据类型: BigInt
const aNumber = 111;
const aBigInt = BigInt(aNumber);
aBigInt === 111n // true

7. 顶层对象: globalThis

8. 空值合并运算符: ??
const someValue = 0;
const defaultValue = 100;
let value = someValue ?? defaultValue; //当左侧的操作数为 null 或者 undefined时，返回其右侧操作数，否则返回左侧操作数。
//|| 操作符，当左侧的操作数为 0 、 null、 undefined、 NaN、 false、 '' 时，都会使用右侧的操作数
9. 可选链操作符：?.
```
