---
title: 防抖与节流函数
date: 2021-5-12
permalink: /pages/0f6a0ac99b62ede5
categories: 
  - 前端
  - JavaScript
tags: 
  - null
  
---

防抖和节流的作用都是在高频事件中防止函数被多次调用，是一种性能优化的方案，在实际开发中还比较常见，处理不当的话对浏览器的性能可能会产生很大的影响。

<!-- more -->

# 防抖与节流函数

## 防抖(debounce)

页面中比较常见的一种情况，如下代码
```javascript
window.onscroll = function(){
  console.log('scroll')
}
```
这是很常见的页面滚动监听事件，当页面做了回到顶部的功能时，就会用到该事件。然而这类监听事件的触发频率非常高，轻轻滚动一下滑轮就可能触发一二十次，给浏览器带来了不必要的性能开销，这时候就需要对这类事件或函数做防抖处理。

### 思路
函数防抖简单来说就是对于一定时间段的连续的函数调用，只让其执行一次，简单的实现思路如下
- 第一次调用函数时，创建一个定时器timeout，指定一个时间
- 如果timeout还未走完而函数又被触发，则重置timeout，函数不执行

### 实现

```javascript
// 防抖函数
function debounce(func, wait = 500) {
  // 定义倒计时器
  let timer = null
  return function (...params) {
    // 如果倒计时没跑完函数被触发，则重新倒计时
    clearTimeout(timer)
    timer = setTimeout(() => {
      timer = null
      func.call(this, ...params)
    }, wait)
  }
}

function func() {
  console. log('scroll')
}
window.onscroll = debounce(func, 500)
```


## 节流(throttle)

节流与防抖功能相似，也是用来控制某个函数在一定时间内执行多少次的技巧，但思想不一样。节流函数是按照固定频率去执行对应的事件处理方法，保证一个事件一定时间内只执行一次。

### 实现

```javascript
// 节流函数
function throttle(func, wait) {
    let timer = null;
    return function (...params) {
        if (!timer) {
            timer = setTimeout(() => {
                timer = null;
                func.call(this, ...params)
            }, wait)
        }
    }
}

function func() {
  console. log('scroll')
}
window.onscroll = throttle(func, 500)
```



