---
title: 数组去重的方法
date: 2021-07-29
permalink: 
categories: 
  - JavaScript
tags: 
  - null
---
set 
sort includes reduce（reduce+includes） indexOf
双层循环：for..of+splice  filter+indexOf  
利用对象的属性不能重复的特点、hasOwnProperty、map
递归去重
# 1.set
```js
Array.from(new Set(arr))
let arr=[...new Set(arr)]
缺点：对空对象无法去重
```
# 2.利用for嵌套for，然后splice去重
```js
function unique(arr){            
  for(var i=0; i<arr.length; i++){
      for(var j=i+1; j<arr.length; j++){
          if(arr[i]==arr[j]){         //第一个等同于第二个，splice方法删除第二个
              arr.splice(j,1);
              j--;
          }
      }
  }
  return arr;
}
```
# 3. 利用indexOf去重
```js
function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return
    }
    var array = [];
    for (var i = 0; i < arr.length; i++) {
         if (array .indexOf(arr[i]) === -1) {
          //  arr.indexOf(arr[i]) === i
            array .push(arr[i])
        }
    }    
    return array;
}
```
# 4. sort()
```js
function unique(arr){
  arr = arr.sort()
  var newArr = [arr[0]]
  for (var i = 1; i < arr.length; i++) {
    if (arr[i] !== newArr[newArr.length - 1]) {
      newArr.push(arr[i])
    }
  }
}
```
# 5. 利用对象的属性特点不能相同的特点去重
```js
function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return
    }
    var arrry= [];
     var  obj = {};
    for (var i = 0; i < arr.length; i++) {
        if (!obj[arr[i]]) {
            arrry.push(arr[i])
            obj[arr[i]] = 1
        } else {
            obj[arr[i]]++
        }
    }    
    return obj;
}
```
# 6. includes
```js
function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return
    }    
    var arrry=[];
    for(let i = 0; i < arr.length; i++) {
      if( !arrry.includes( arr[i]) ) {//includes 检测数组是否有某个值
          arrry.push(arr[i]);
        }
    }
    return arrry
}
```
# 7. 利用hasOwnProperty
```js
function unique(arr) {
    var obj = {};
    return arr.filter(function(item, index, arr){
      console.log(typeof item + item)
      console.log(obj.hasOwnProperty(typeof item + item))
        return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true)
    })
}
```
# 8. filter
```js
function unique(arr) {
  return arr.filter(function(item, index, arr) {
    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
    return arr.indexOf(item, 0) === index;
  });
}
```
# 9. 利用递归去重
```js
function unique(arr) {
        var arrry= arr;
        var len = arrry.length;

    arrry.sort(function(a,b){   //排序后更加方便去重
        return a - b;
    })
        
    function loop(index){
        if(index >= 1){
            if(arrry[index] === arrry[index-1]){
                arrry.splice(index,1);
            }
            loop(index - 1);    //递归loop，然后数组去重
        }
    }
    loop(len-1);
    return arrry;
}
```
# 10.利用Map数据结构去重
```js
function arrayNonRepeatfy(arr) {
  let map = new Map();
  let array = new Array();  // 数组用于返回结果
  for (let i = 0; i < arr.length; i++) {
    if(map.has(arr[i])) {  // 如果有该key值
      map.set(arr[i], true); 
    } else { 
      map.set(arr[i], false);   // 如果没有该key值
      array.push(arr[i]);
    }
  } 
  return array ;
}
```
# 11. reduce
```js
Array.prototype.unique = function() {
  var sortArr = this.sort();
  var array = [];
  sortArr.reduce((s1,s2) => {
    if(s1 !== s2){
      array .push(s1);
    }
    return s2;
  })
  array.push(sortArr[sortArr.length - 1]);
  return array ;
}
```