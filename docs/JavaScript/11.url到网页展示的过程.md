---
title: 网址输入url之后发生了什么？
date: 2021-07-23
permalink: 
categories: 
  - 网址输入url之后发生了什么？
tags: 
  - null
---
# 1. URL 解析
```js
1. 地址解析（ARP 地址解析协议）
首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。
2. 补全域名
浏览器会对一些默认的东西进行补齐。补充默认端口号80，补充域名等。
2. HSTS
3. 其他操作
4. 检查缓存
浏览器的缓存机制
`一般简单的请求会进行缓存，例如index.js，.png`
1）为什么需要缓存？
减少网络带宽消耗、降低服务器压力、减少网络延迟，加快页面打开速度
2）如定义缓存?
  1. HTML页面的Meta标签
  //<meta http-equiv="Pragma" content="no-cache">  
  // http1.0是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取
  2. HTTP协议头
3) 缓存的种类
  1. 强制缓存: 请求返回200的状态码，并且size显示from disk cache或from memory cache；
    强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。
    三种情况：
    1）不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）
    2）存在该缓存结果和缓存标识，但是结果已经失效，强制缓存失效，则使用协商缓存（暂不分析）
    3）存在该缓存结果和缓存标识，且该结果没有还没有失效，强制缓存生效，直接返回该结果
    `Expires`和`Cache-Control`,`其中Cache-Conctrol的优先级比Expires高`
    `Expires`（HTTP1.0）:缓存的到期时间，时间之内直接使用，之外则缓存失效  ,其原理是使用客户端时间与服务器返回的时间作比较。
    `Cache-Control`:主要控制网页的缓存
    （1）public：所有内容都将被缓存（客户端和代理服务器都可缓存）
    （2）private：所有内容只有客户端可以缓存，Cache-Control的默认取值
    （3）no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
    （4）no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
    （5）max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效
  2. 协商缓存
    协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。
    （1）协商缓存生效，返回304，页面无更新
    （2）协商缓存失败，返回200和请求结果，并将新的结果存到浏览器缓存中。
    `Last-Modified / If-Modified-Since`和`Etag / If-None-Match`,`Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高`
    `Last-Modified / If-Modified-Since`
    `Last-Modified`: 返回服务器最后修改的时间
    `If-Modified-Since`: 客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件。
    缺点：
    1. 如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。
    2. 如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。
    `Etag / If-None-Match`
    `Etag`: 服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)
    `If-None-Match`: 客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值,类似`If-Modified-Since`
  4. 使用场景
    1. 地址栏访问，链接跳转是正常用户行为，将会触发浏览器缓存机制； 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。
    2. F5刷新，浏览器会设置max-age=0，跳过强缓存判断，会进行协商缓存判断；因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。
    3. ctrl+F5刷新，跳过强缓存和协商缓存，直接从服务器拉取资源。
  5. 缓存的位置
    1. Service Worker
    如果 Service Worker 没能命中缓存，一般情况会使用 fetch() 方法继续获取资源。这时候，浏览器就去 memory cache 或者 disk cache 进行下一次找缓存的工作了。
    2. Memory Cache 短期存储
    几乎所有的网络请求资源都会被浏览器自动加入到 memory cache 中。
      1. preloader预加载器
      在浏览器解析的空闲时间中，来预加载。一个常见的集合似乎是来自<img>标签的脚本、外部 CSS 和图像。 @import等
      2. preload
      <link rel="preload"/>预加载资源
      3. 保证了一个页面中如果有两个相同的请求 (例如两个 src 相同的 <img>，两个 href 相同的 <link>)都实际只会被请求最多一次，避免浪费。
    3. Disk Cache 持久存储
    会严格根据 HTTP 头信息中的各类字段来判定哪些资源可以缓存，
    4. 网络请求
```
# 2. DNS查询(是进行域名和与之相对应的 IP 地址进行转换的服务器)
```js
`域名`：从上到下一次为根域名、顶级域名、二级域名、三级域名...
1. 查询方式：
    1. 递归查询 ：如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案，循环遍历别人
    2. 迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求。
2. 域名缓存
    1. 浏览器DNS缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗
    2. 操作系统缓存：操作系统的缓存其实是用户自己配置的 hosts 文件
3. 查询过程
    1. 首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表
    2. 若没有命中，则继续搜索操作系统的 DNS 缓存 (路由器缓存、ips DNS缓存)
    3. 若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果
    4. 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询
        首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器
        本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址
        本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址
    5. 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来
    6. 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起
    至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起
```
# 3. TCP连接
```js
四层：应用层（发送 HTTP 请求）、传输层（TCP 传输报文）、网络层（IP协议查询Mac地址）、链路层（以太网协议）
```
# 4. 服务器处理请求
# 5. 浏览器接受响应
```js
浏览器接收到来自服务器的响应资源后，会对资源进行分析。
```
# 6.渲染页面
```js
1. HTML解析
   ① 解码（encoding）
　　　　传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如UTF-8）转换成字符串，也就是HTML 代码。
　　② 预解析（pre-parsing）
　　　　预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如img标签的src属性，并将这个请求加到请求队列中。
　　③ 符号化（Tokenization）
　　　　符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。
　　　　它通过一个状态机去识别符号的状态，比如遇到<，>状态都会产生变化。
　　④ 构建树（tree construction）
2. CSS解析
    一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据语法规范[4]解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。
　　CSS 匹配规则
　　在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：div p { font-size :14px }会先寻找所有的p标签然后判断它的父元素是否为div。
3. 渲染树
   DOM 树和 CSS 规则树合并
   1. 计算
   2. 级联 （specificity公式)
4. 布局与绘制
5. 合并渲染层
6. 回流与重绘
```js
回流出现的情况：
  1、添加或删除可见的DOM元素
  2、元素的位置发生变化
  3、元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
  4、内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
  5、页面一开始渲染的时候（这肯定避免不了）
  6、浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）
  最复杂的一种：获取某些属性，引发回流
  (1) offset(Top/Left/Width/Height)
  (2) scroll(Top/Left/Width/Height)
  (3) cilent(Top/Left/Width/Height)
  (4) width,height
  (5) 调用了getComputedStyle()或者IE的currentStyle
重绘出现的情况：
  是指在布局和几何大小都不变得情况下，比如次改一下background-color,或者改动一下字体颜色的color等。
```如何减少重绘与回流？```
1、CSS优化法
（1）使用 transform 替代 top
（2）使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局
（3）避免使用table布局，可能很小的一个小改动会造成整个 table 的重新布局。
（4）尽可能在DOM树的最末端改变class，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。
（5）避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。
（6）将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 requestAnimationFrame，详见探讨 requestAnimationFrame。
（7）避免使用CSS表达式，可能会引发回流。
（8）将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如will-change、video、iframe等标签，浏览器会自动将该节点变为图层。
（9）CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。
2、JavaScript优化法
（1）避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。
（2）避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。 
（3）避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
```
7. js编译执行
   1. 词法分析：分词、解析(AST)、代码生成
   2. 预编译
    运行环境：全局环境、函数环境、eval
    每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。
    创建执行上下文的过程中，主要做了以下三件事：
        1. 创建变量对象
        参数、函数、变量
        2. 建立作用域链
        确认当前执行环境是否能访问变量
        3. 确定 This 指向
   3. 执行
    `JS 引擎线程`(主要)和`事件触发线程`、`定时器触发线程`、`HTTP 异步请求线程`（协助）
```
