---
title: 网址输入url之后发生了什么？
date: 2021-07-23
permalink: 
categories: 
  - 网址输入url之后发生了什么？
tags: 
  - null
---
# 1. URL 解析
```js
1. 地址解析（ARP 地址解析协议）
首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。
2. 补全域名
浏览器会对一些默认的东西进行补齐。补充默认端口号80，补充域名等。
2. HSTS
3. 其他操作
4. 检查缓存
浏览器的缓存机制
`post请求不能被缓存`
1）为什么需要缓存？
减少网络带宽消耗、降低服务器压力、减少网络延迟，加快页面打开速度
2）如定义缓存?
  1. HTML页面的Meta标签
  //<meta http-equiv="Pragma" content="no-cache">  
  // 是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取
  2. HTTP协议头
3) 缓存的种类
  1. 强制缓存
    强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。
    三种情况：
    1）不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）
    2）存在该缓存结果和缓存标识，但是结果已经失效，强制缓存失效，则使用协商缓存（暂不分析）
    3）存在该缓存结果和缓存标识，且该结果没有还没有失效，强制缓存生效，直接返回该结果
    `Expires`和`Cache-Control`,其中Cache-Conctrol的优先级比Expires高
    `Expires`（HTTP1.0）:缓存的到期时间，时间之内直接使用，之外则缓存失效  ,其原理是使用客户端时间与服务器返回的时间作比较。
    `Cache-Control`:主要控制网页的缓存
    （1）public：所有内容都将被缓存（客户端和代理服务器都可缓存）
    （2）private：所有内容只有客户端可以缓存，Cache-Control的默认取值
    （3）no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
    （4）no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
    （5）max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效
    缓存存放的位置size： from memory cache代表使用内存中的缓存,from disk cache则代表使用的是硬盘中的缓存。先读取内存缓存再读取硬盘缓存。
  2. 协商缓存
    协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。
    （1）协商缓存生效，返回304，页面无更新
    （2）协商缓存失败，返回200和请求结果，并将新的结果存到浏览器缓存中。
    `Last-Modified / If-Modified-Since`和`Etag / If-None-Match`,Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高
    `Last-Modified / If-Modified-Since`
    `Last-Modified`: 返回服务器最后修改的时间
    `If-Modified-Since`: 客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件。
    `Etag / If-None-Match`
    `Etag`: 服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)
    `If-None-Match`: 客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值,类似`If-Modified-Since`
```
# 2. DNS查询(是进行域名和与之相对应的 IP 地址进行转换的服务器)
```js
`域名`：从上到下一次为根域名、顶级域名、二级域名、三级域名...
1. 查询方式：
    1. 递归查询 ：如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案，循环遍历别人
    2. 迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求。
2. 域名缓存
    1. 浏览器DNS缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗
    2. 操作系统缓存：操作系统的缓存其实是用户自己配置的 hosts 文件
3. 查询过程
    1. 首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表
    2. 若没有命中，则继续搜索操作系统的 DNS 缓存 (路由器缓存、ips DNS缓存)
    3. 若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果
    4. 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询
        首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器
        本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址
        本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址
    5. 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来
    6. 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起
    至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起
```
# 3. TCP连接
```js
四层：应用层（发送 HTTP 请求）、传输层（TCP 传输报文）、网络层（IP协议查询Mac地址）、链路层（以太网协议）
```
# 4. 服务器处理请求
# 5. 浏览器接受响应
```js
浏览器接收到来自服务器的响应资源后，会对资源进行分析。
```
# 6.渲染页面
```js
1. HTML解析
   ① 解码（encoding）
　　　　传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如UTF-8）转换成字符串，也就是HTML 代码。
　　② 预解析（pre-parsing）
　　　　预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如img标签的src属性，并将这个请求加到请求队列中。
　　③ 符号化（Tokenization）
　　　　符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。
　　　　它通过一个状态机去识别符号的状态，比如遇到<，>状态都会产生变化。
　　④ 构建树（tree construction）
2. CSS解析
    一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据语法规范[4]解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。
　　CSS 匹配规则
　　在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：div p { font-size :14px }会先寻找所有的p标签然后判断它的父元素是否为div。
3. 渲染树
   DOM 树和 CSS 规则树合并
   1. 计算
   2. 级联 （specificity公式)
4. 布局与绘制
5. 合并渲染层
6. 回流与重绘
7. js编译执行
   1. 词法分析：分词、解析(AST)、代码生成
   2. 预编译
    运行环境：全局环境、函数环境、eval
    每进入一个不同的运行环境都会创建一个对应的执行上下文，根据不同的上下文环境，形成一个函数调用栈，栈底永远是全局执行上下文，栈顶则永远是当前执行上下文。
    创建执行上下文的过程中，主要做了以下三件事：
        1. 创建变量对象
        参数、函数、变量
        2. 建立作用域链
        确认当前执行环境是否能访问变量
        3. 确定 This 指向
   3. 执行
    `JS 引擎线程`(主要)和`事件触发线程`、`定时器触发线程`、`HTTP 异步请求线程`（协助）
```
