---
title: 数组排序的方法
date: 2021-08-04
permalink: 
categories: 
  - JavaScript
tags: 
  - null
---
# sort
```js
let arr=[1,9,9,30,2,2,3]
arr.sort()
arr.sort(()=>{return a-b})
本质：调用toString方法进行比较
```
# 1.冒泡排序法
```js
var arr=[1,3,4,2,2,0,10];
var news="";
for(var i=0;i<arr.length;i++){
  for(var j=0;j<arr.length-i;j++){
    if(arr[j]>arr[j+1]){
      news=arr[j];
      arr[j]=arr[j+1];
      arr[j+1]=news;
    }
  }
}
```
# 2.选择排序法
```js
将要排序的数组分成两部分，一部分是从大到小已经排好序的，一部分是无序的，从无序的部分取出最小的放到已经排序的最后面
var arr=[13,16,18,19,11,0]
function minnum(arr){
  for(var i=0;i<arr.length;i++){
    var m=i;
    for(var j=i+1;j<arr.length;j++){
      if(arr[j]<arr[m]){
        m=j
      }
    }
    if(m!==i){
      var news=arr[i];
      arr[i]=arr[m];
      arr[m]=news;
    }
  }
  return arr;
}
```
# 3.插入排序法
```js
将要排序的数组分成两部分，每次从后面的部分取出索引最小的元素插入到前一部分的适当位置
var arr = [3,4,1,2,21,5,15,6,63];
function InsertSort(ary){
    var temp;
    for (var i = 1; i < ary.length; i++) {
        for (var j = i-1; j >=0; j--) {
            if (ary[j+1] < ary[j]) {
                temp = ary[j+1];
                ary[j+1] = ary[j];
                ary[j] = temp;
            } else if (ary[j+1] >= ary[j]) {
                break;
            }
        }
    }
    return ary;
}
```
# 4. 快速排序法
```js
从数组中找一个基准值，通过这个值挨个和数组中的值进行比较，大的放一边，小的放一边，然后进行合并后，在进行比较，反复直至结束。
var arr = [3,4,1,2,21,5,15,6,63];
var quickSort = function(ary) {
    if (ary.length <= 1) {
        return ary;
    }
    var pivotIndex = Math.floor(ary.length / 2);
    var pivot = ary.splice(pivotIndex, 1)[0];
    var left = [];
    var right = [];
 
    for (var i = 0; i < ary.length; i++) {
        if (ary[i] < pivot) {
            left.push(ary[i]);
        } else {
            right.push(ary[i]);
        }
    }
    return quickSort(left).concat([pivot], quickSort(right));
};
 
quickSort(arr);  // [1, 2, 3, 4, 5, 6, 15, 21, 63]
```
# 5. 堆排序
```js
堆是一棵顺序存储的二叉树，堆分为最大堆和最小堆，最大堆父节点都大于子节点, 最小堆父节点都小于子节点，左子节点: 2*i +1 (i: 父节点index)，右子节点: 2*i+2，从最后一个非叶子节点开始将堆进行小顶堆排序，每次拿出根节点,并和最后一个节点进行交换，重新进行堆的建立。
var arr = [3,4,1,2,21,5,15,6,63];
function HeapSort(ary) {
     // 实现最大堆
     // start: 父节点, end: 循环深度
    function maxHeap(ary, start, end) {
        let parent = start, // 父节点
        son = parent*2 + 1, // 左子节点
        temp = null;
        // 规定循序最大深度
        while(son<=end) {
            // 如果存在右子节点, 并且判断右节点是否大于左节点
            if(son+1<=end && ary[son] < ary[son+1]) son++;
            if(ary[son] > ary[parent]) {
                temp = ary[son];
                ary[son] = ary[parent];
                ary[parent] = temp;
                parent = son;
                son = parent*2 +1;
            }else {
                return;
            }
        }
    }
    // 构建最大堆  ary.length/2-1: 表示最后一个父节点
    for(let i = ary.length/2-1; i>=0; i--) {
        maxHeap(ary, i, ary.length-1);
    }
    // 排序
    for(let i = ary.length-1; i>0; i--) {
        let temp = ary[0];
        ary[0] = ary[i];
        ary[i]= temp;
        // 剔除最后一个元素,并复原最大堆
        maxHeap(ary, 0, i-1);
    }
    return ary;
}
 
HeapSort(arr); // [1, 2, 3, 4, 5, 6, 15, 21, 63]
```
# 6.归并排序
```js
将长的数组分解为短的数组，一直分到最后，单个单个数组比较，我们就认为，只有一个元素的数组是有序的。然后再逐个的合并。
var arr = [3,4,1,2,21,5,15,6,63];
function MergeSort(ary) {  //采用自上而下的递归方法
    var len = ary.length;
    if(len < 2) {
        return ary;
    }
    var middle = Math.floor(len / 2),
        left = ary.slice(0, middle),
        right = ary.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}
 
function merge(left, right)
{
    var result = [];
 
    while (left.length && right.length) {
        if (left[0] <= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }
 
    while (left.length)
        result.push(left.shift());
 
    while (right.length)
        result.push(right.shift());
 
    return result;
}
 
MergeSort(arr); // [1, 2, 3, 4, 5, 6, 15, 21, 63]
```
# 7.希尔排序
```js
希尔排序是插入排序的一种更高效率的实现。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。
var arr = [3,4,1,2,21,5,15,6,63];
function ShellSort(ary) {
    var len = ary.length,
        temp,
        gap = 1;
    while(gap < len/3) {          //动态定义间隔序列
        gap =gap*3+1;
    }
    for (gap; gap > 0; gap = Math.floor(gap/3)) {
        for (var i = gap; i < len; i++) {
            temp = ary[i];
            for (var j = i-gap; j >= 0 && ary[j] > temp; j-=gap) {
                ary[j+gap] = ary[j];
            }
            ary[j+gap] = temp;
        }
    }
    return ary;
}
 
ShellSort(arr); // [1, 2, 3, 4, 5, 6, 15, 21, 63]
```
# 8.计数排序
```js
  1、找出待排序的数组中最大和最小的元素，然后建立一个数组C用于统计待排数组中最小元素到最大元素区间中每个元素出现次数；
　2、统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
  3、对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；
  4、反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。
  var arr = [3,4,1,2,21,5,15,6,63];
function CountSort(ary){
    let obj={};
    for(let i=0; i<ary.length; i++){
        if(!obj[ary[i]]){
            obj[ary[i]]=1;
        }else{
            obj[ary[i]]++;
        }
    }
    let index=0;
    //遍历对象属性名，按顺序放回覆盖原数组
    for(let key in obj){
        while(obj[key]>0){
            ary[index]=Number(key);
            obj[key]--;
            index++
        }
    }
    return ary;
}
 
CountSort(arr); // [1, 2, 3, 4, 5, 6, 15, 21, 63]
```
# 9. 桶排序
```js
1. 设置固定数量的空桶。
2. 把数据放到对应的桶中。
3. 对每个不为空的桶中数据进行排序。
4. 拼接不为空的桶中数据，得到结果
function bucketSort(array, bucketSize = 5) { // {1} 
 if (array.length < 2) { 
 return array; 
 } 
 const buckets = createBuckets(array, bucketSize); // {2} 
 return sortBuckets(buckets); // {3} 
}
function createBuckets(array, bucketSize) { 
 let minValue = array[0]; 
 let maxValue = array[0]; 
 for (let i = 1; i < array.length; i++) { // {4} 
 if (array[i] < minValue) { 
 minValue = array[i]; 
 } else if (array[i] > maxValue) { 
 maxValue = array[i]; 
 } 
 } 
 const bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; // {5} 
 const buckets = []; 
 for (let i = 0; i < bucketCount; i++) { // {6} 
 buckets[i] = []; 
 } 
 for (let i = 0; i < array.length; i++) { // {7} 
 const bucketIndex = Math.floor((array[i] - minValue) / bucketSize); // {8} 
 buckets[bucketIndex].push(array[i]); 
 } 
 return buckets; 
}
```
# 10. 基数排序
```JS
1. 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零
2. 从最低位开始，依次进行一次排序
3. 从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列
function radixSort(array, radixBase = 10) { 
if (array.length < 2) { 
return array; 
}
const maxValue = findMaxValue(array); 
let significantDigit = 1; // {1} 
while ((maxValue - minValue) / significantDigit >= 1) { // {2} 
array = countingSortForRadix(array, radixBase, significantDigit, minValue); // {3} 
significantDigit *= radixBase; // {4} 
} 
return array; 
}
```