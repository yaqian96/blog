---
title: 深拷贝和浅拷贝
date: 2021-07-23
permalink: 
categories: 
  - 代理
tags: 
  - null
---
# 1. 概念
深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。
# 2. 本质
浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。
深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。
# 3. 赋值和浅拷贝的区别
赋值：和原数据是指向同一对象，改变会使得原数据一起改变
浅拷贝：和原数据是指向不是同一对象，第一层为基础数据类型，不会改变，原数据中包含子对象会改变
# 4. 浅拷贝的实现方式
```js
1. Object.assign() //对非嵌套对象进行深拷贝的方法
`当object只有一层的时候，是深拷贝`
2. Array.prototype.concat() //适合一维数组
let arr = [1, 3, {
   username: 'kobe'
}];
let arr2=arr.concat();    
arr2[2].username = 'wade';
console.log(arr);
3. Array.prototype.slice() //适合一维数组
4. for...in 循环遍历赋值
5. 扩展运算符
```
# 5.深拷贝的实现方式
```js
1. JSON.parse(JSON.stringify())
    缺点：
    1. 不能处理函数
    2. 如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式。而不是时间对象
    3. 如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象
    4. 如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失
    5. 如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null
    6. JSON.stringify()只能序列化对象的可枚举的自有属性,例如 如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象constructor
    function Person(name) {
        this.name = name;
        console.log(name)
      }
      
      const liai = new Person('liai');
      
      const test = {
        name: 'a',
        date: liai,
      };
      // debugger
      const copyed = JSON.parse(JSON.stringify(test));
      test.name = 'test'
      console.error('ddd', test, copyed)
    7. 如果对象中存在循环引用的情况也无法正确实现深拷贝
    8. 不支持Symbol
2. 手写克隆函数
function isObject(obj) {
  return typeof obj === 'object' && obj !== null;
}
function deepCopy(souce) {
  if (!isObject(souce)) return souce;
  let target = Array.isArray(souce) ? [] : {};
  for( var k in souce) {
    if (souce.hasOwnProperty(k)) {
      if (souce[k] && typeof souce[k] === 'object') {
        target[k] = deepCopy(souce[k]);
      } else {
        target[k] = souce[k];
      }
    }
  }
  return target;
}
 // 定义检测数据类型的功能函数
 class DeepClone {
  constructor() {
    this.cacheList = [];
  }
  clone(source) {
    if (source instanceof Object) {
      const cache = this.findCache(source); // 如果找到缓存，直接返回
      if (cache) return cache;
      else {
        let target;
        if (target instanceof Array) {
          target = new Array();
        } else if (target instanceof Function) {
          target = function () {
            return source.apply(this, arguments);
          };
        } else if (target instanceof Date) {
          target = new Date(source);
        } else if (target instanceof RegExp) {
          target = new RegExp(source.source, source.flags);
        } else {
          target = new Object(); // 不要忘记普通对象
        }

        this.cacheList.push([source, target]); // 把原对象和新对象放进缓存列表
        for (let key in source) {
          if (source.hasOwnProperty(key)) {
            // 不拷贝原型上的属性，浪费内存
            target[key] = this.clone(source[key]); // 递归
          }
        }
        return target;
      }
    } else {
      return source;
    }
  }
  findCache(source) {
    for (let i = 0; i < this.cacheList.length; ++i) {
      if (this.cacheList[i][0] === source) {
        return this.cacheList[i][1];
      }
    }
  }
}
3. 函数库lodash
var _ = require('lodash');
var obj1 = {
   a: 1,
   b: { f: { g: 1 } },
   c: [1, 2, 3]
};
var obj2 = _.cloneDeep(obj1);
console.log(obj1.b.f === obj2.b.f);
4. $.extend([deep],target,object1,...)
```


