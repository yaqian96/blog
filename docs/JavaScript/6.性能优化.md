---
title: 性能优化的解决方法
date: 2021-06-29
permalink: 
categories: 
  - JavaScript
tags: 
  - null
---
https://zhuanlan.zhihu.com/p/121056616
# 前端性能方面一般分为：网络方面、js、css、渲染、打包、SEO
```js
网络方面
1. 减少http请求：合并js文件/合并css文件/雪碧图的使用(css sprite)/使用base64表示简单的图片
2. 使用HTTP/2
多路复用、二进制分帧、服务器推送、头部压缩。
HTTP/3: QUIC协议
    QUIC协议有以下特点：
    1. 基于UDP的传输层协议：它使用UDP端口号来识别指定机器上的特定服务器。
    2. 可靠性：虽然UDP是不可靠传输协议，但是QUIC在UDP的基础上做了些改造，使得他提供了和TCP类似的可靠性。它提供了数据包重传、拥塞控制、调整传输节奏以及其他一些TCP中存在的特性。
    3.实现了无序、并发字节流：QUIC的单个数据流可以保证有序交付，但多个数据流之间可能乱序，这意味着单个数据流的传输是按序的，但是多个数据流中接收方收到的顺序可能与发送方的发送顺序不同！
    4. 快速握手：QUIC提供0-RTT和1-RTT的连接建立
    使用TLS 1.3传输层安全协议：与更早的TLS版本相比，TLS 1.3有着很多优点，但使用它的最主要原因是其握手所花费的往返次数更低，从而能降低协议的延迟
`http的协议版本`
HTTP/0.9
它不涉及数据包（packet）传输,GET请求。
HTTP/1.0
  1. 任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。
  2. 除了 GET 命令，还引入了 POST 命令和 HEAD 命令，丰富了浏览器与服务器的互动手段。
  3. HTTP 请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。
  其他的新增功能还包括状态码**（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）**等
HTTP/1.1
  1. 长连接
  2. 缓存
  3. 带宽优化及网络连接的使用
  4. 错误通知的管理
  5. Host 头处理
HTTP/2
  1. 多路复用
  2. 请求优先级
  3. header 压缩。
  4. 基于 HTTPS 的加密协议传输，大大提高了传输数据的可靠性
  5. 服务端推送（server push)
2. 减小资源体积：gzip压缩/js混淆/css压缩/图片压缩
3. 缓存：DNS缓存 /CDN部署与缓存 /http缓存
4. 移动端优化：/使用长cache，减少重定向/首屏优化，保证首屏加载数据小于14kb/不滥用web字体
5. 静态资源使用 CDN
6. 减少cookie传输
```
```js
css的文件放在头部，js文件放在尾部或者异步、尽量避免內联样式
js
1. js写在body底部
2. js用defer放在头部，提前加载时间，又不阻塞dom解析
3. script标签添加crossorigin，方便错误收集
4. 慎用with, 避免使用 eval和 Function
css
1. 小图使用雪碧图，iconFont，base64内联
2. webp代替其他格式
3. 图片的懒加载
4. 动画尽量采用css3实现
5. 降低 CSS 选择器的复杂性
6. 避免行内style样式
7. 可以使用的img的srcset，根据不同分辨率显示不同尺寸图片，这样既保证显示效果，又能节省带宽，提高加载速度
渲染
1. 尽量减少reflow和repaint
   涉及到样式，尺寸，节点增减的操作，都会触发reflow和repaint。
    1.1 用变量缓存dom样式，不要频繁读取
    1.2 通过DocumentFragment或innerHTML批量操作dom
    1.3 dom隐藏，或复制到内存中，类似virtual dom，进行修改，完成后再替换回去
    1.4 动画元素一定要absolute，脱离文档流，不影响其他元素。动画不要用left，top等操作，要使用transform和opacity，同时开启渲染层(will-change或translate3d(0,0,0))
    1.5 动画尽量用requestAnimationFrame，不要用定时器
    1.6 移动端硬件加速，触发GPU渲染，还是translate3d(0,0,0)
2. 尽量用css动画代替js动画，canvas动画代替js动画
3. 初始渲染，可以使用骨架屏或loading，提升体验
4. PWA，可以本地缓存资源，提升体验
5. 频繁触发的事件，防抖、节流，例如：scroll，input等
6. 长列表，使用分页或滚动加载，虚拟列表，移除屏外dom
7. 首屏加载
    1. 代码分离，将首屏不需要的代码分离出去
    2. 服务端渲染或预渲染，加载完html直接渲染，减少白屏时间
    3. DNS prefetch，使用dns-prefetch减少dns查询时间，PC端域名发散，移动端域名收敛
    4. 减少关键路径css，可以将关键的css内联，这样可以减少加载和渲染时间
8. 预渲染和服务器端渲染
```
```js
webpack
1. 拆包 externals dllPlugin
2. 提取公共包 commonChunkPlugin或splitChunks
3. 缩小范围 各种loader配置include和exclude，noParse跳过文件
4. 开启缓存 各种loader开启cache
5. 多线程加速 happypack或thead-loader
6. tree-shaking ES模块分析，移除死代码
7. Scope Hoisting ES6模块分析，将多个模块合并到一个函数里，减少内存占用，减小体积，提示运行速度
8. webpack长缓存优化
    1. js文件使用chunkhash，不使用hash
    2. css文件使用contenthash，不使用chunkhash，不受js变化影响
    3. 提取vendor，公共库不受业务模块变化影响
    4. 内联webpack runtime到页面，chunkId变化不影响vendor
    5. 保证module Id稳定，不使用数字作为模块id，改用文件内容的hash值，使用HashedModuleIdsPlugin，模块的新增或删除，会导致其后面的所有模块id重新排序，为避免这个问题
    6. 保证chunkhash稳定，使用webpack-chunk-hash，替代webpack自己的hash算法。webpack自己的hash算法，对于同一个文件，在不同开发环境下，会计算出不用的hash值，不能满足跨平台需求。
```
```js
10. SEO优化
  1. 添加各种meta信息
```
