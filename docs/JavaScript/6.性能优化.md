---
title: 性能优化的解决方法
date: 2021-06-29
permalink: 
categories: 
  - JavaScript
tags: 
  - null
---
https://zhuanlan.zhihu.com/p/121056616
# 前端性能方面一般分为：加载时优化和运行时优化
## 加载时优化
```js
1. 减少HTTP的请求
     一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程。
     原因：因为一个真正的http请求中，文件越大，下载数据的占比越高，因此建议将 `多个小文件合并成一个大文件`，节省时间
2. 使用 HTTP2
// http1.1 http2 的优缺点
解析速度快 
多路复用 
首部压缩 （客户端和服务端会创建一个表，如果首部相同，则根据索引将请求还原成完整的首部）
优先级 (紧急的优先设置) 
流量控制 
服务器推送，一个客户端请求，多个响应
// http2
HTTP 2.0 增加了新的二进制分帧数据层
现在的主流浏览器 HTTP/2 的实现都是基于 SSL/TLS 的，也就是说使用 HTTP/2 的网站都是 HTTPS 协议的，所以本文只讨论基于 SSL/TLS 的 HTTP/2 连接建立过程。
// http1.1(一般使用)的缺点
对头阻塞 低效率的TCP利用 消息首部很大 受限的优先级设置
3. 采用服务端渲染 （nuxt）
优点：更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面,更快的内容到达时间。
4. 静态使用CDN
内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器
5. 将 CSS 放在文件头部，JavaScript 文件放在底部
实现让浏览器先加载css html js ,js也可以放在头部，异步下载，延迟执行
6. 使用字体图标 iconfont 代替图片图标
压缩字体文件 （fontmin-webpack ）
7. 善用缓存，不重复加载相同的资源
Expires 或 max-age 
`通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。`
`数据摘要算法`：对文件求摘要信息，摘要信息与文件的内容一一对应
配置超长时间的本地缓存                 —— 节省带宽，提高性能
采用内容摘要作为缓存更新依据      —— 精确的缓存控制
静态资源CDN部署                           —— 优化网络请求
更资源发布路径实现非覆盖式发布  —— 平滑升级
8. 压缩文件
webpack:
JavaScript：UglifyPlugin
CSS ：MiniCssExtractPlugin
HTML：HtmlWebpackPlugin
gzip压缩：
HTTP请求中 Accept-Encoding 头添加 gzip
compression-webpack-plugin
compression
9. 图片优化
（1）图片延迟加载
  <img data-src="https://avatars0.githubusercontent.com/u/22117876?s=460&u=7bd8f32788df6988833da6bd155c3cfbebc68006&v=4"/>
  //页面可见时，进行赋值
  const img = document.querySelector('img')
  img.src = img.dataset.src
（2）响应式图片（根据屏幕大小自动加载合适的图片）
 (3) 调整图片大小
 (4) 降低图片质量 image-webpack-loader 和 在线压缩
 (5) 尽可能利用 CSS3 效果代替图片
 (6) 使用 webp 格式的图片
10. 通过 webpack 按需加载代码，提取第三库代码，减少 ES6 转为 ES5 的冗余代码
  根据文件内容生成文件名，结合 import 动态引入组件实现按需加载
  提取第三方库
  减少 ES6 转为 ES5 的冗余代码
```
## 渲染时优化
```js
11. 减少重绘和重排
导致重排的操作：
添加或删除可见的 DOM 元素
元素位置改变
元素尺寸改变
内容改变
浏览器窗口尺寸改变
如何减少重排重绘？
用 JavaScript 修改样式时，最好不要直接写样式，而是替换class来改变样式。如果要对 DOM 元素执行一系列操作，可以将 DOM 元素脱离文档流，修改完成后，再将它带回文档。推荐使用隐藏元素（display:none）或文档碎片（DocumentFragement），都能很好的实现这个方案。
12. 事件委托
13. 注意程序的局部性
时间局部性：在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来被多次引用。
空间局部性 ：在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。
14. if-else 对比 switch
当条件值大于两个的时候，使用switch
15. 查找表
const results = [result0,result1,result2,result3,result4,result5,result6,result7,result8,result9,result10,result11]
return results[index]
16. 避免页面卡顿
  60fps 与设备刷新率
17. 使用 requestAnimationFrame 来实现视觉变化
在使用 JavaScript 实现动画效果的时候，最好的情况就是每次代码都是在帧的开头开始执行。而保证 JavaScript 在帧开始时运行的唯一方式是使用 requestAnimationFrame。
18. 使用 Web Workers
19. 使用位操作
js中以64位格式存储，但是在位操作中，数字被转换成有符号的32位格式
// 位操作
if (value & 1) {
    // 奇数
} else {
    // 偶数
}
~~10.12 // 10
~~10 // 10
~~'1.5' // 1
~~undefined // 0
~~null // 0
const a = 1
const b = 2
const c = 4
const options = a | b | c
// 选项 b 是否在选项中
if (b & options) {
    ...
}
20. 不要覆盖原生方法
21. 降低 CSS 选择器的复杂性
(1). 浏览器读取选择器，遵循的原则是从选择器的右边到左边读取。
(2). CSS 选择器优先级
22. 使用 flexbox 而不是较早的布局模型（兼容性问题）
23. 使用 transform 和 opacity 属性更改来实现动画
24. 合理使用规则，避免过度优化
```