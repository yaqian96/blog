---
title: 设计模式
date: 2021-07-28
categories:
  - 设计模式
tags:
  - 
---
# 1. 设计模式的六大原则
```js
1. 开闭原则
一个软件实体如类、模块和函数，应该对修改封闭，对扩展开放
2. 单一职责原则
一个类只做一个事情，一个类应该只有一个引起它修改的原因
3. 里氏替换原则
在使用继承时，只扩展新功能，而不破坏父类原有的功能。
4. 依赖倒置原则
细节应该依赖于抽象，而抽象不应该依赖细节。抽象层放在程序设计的高层，并保持稳定，程序的细节变化应该有低层的实现层来完成
5. 迪米特法则（最少知道原则）
一个类不应知道自己操作的类的细节
6. 接口隔离原则
客户端不应该依赖他不需要的接口。实现类只需要依赖自己需要的接口方法。
```
# 构造型模式----5种  
```js
1. `工厂模式`
  1.1 简单工厂模式 //直接通过构造函数new 对象，对象中有构造函数的方法，统一设置一个构造函数
  缺点：1. 导致类会很大 2. 想往类中添加东西，破坏开闭原则
  1.2 工厂方法模式 //将每个类划分开来，单独进行构造函数设置
  优点：1. 类的种类会多，不会臃肿 2. 新的东西只需要增加类
  1.3 `抽象工厂模式` //此工厂当作抽象的 IFactory 接口使用即可
  缺点：IFactory 接口需要新增功能，则会影响到所有的具体工厂类
3. `单例模式` //某个对象全局只需要一个实例时，就可以使用单例模式
  特点：1. 它能够避免对象重复创建，节约空间并提升效率
        2. 避免由于操作不同实例导致的逻辑错误
  实现方式：饿汉式和懒汉式。
  饿汉式：变量在声明时便初始化。
  懒汉式：先声明一个空变量，需要用时才初始化。
4. `建造型模式` //建造型模式用于创建过程稳定，但配置多变的对象。
5. `原型模式`  //用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
```
# 结构性模式---7种   一般是解决不同的类之间有不同关系的情况。
```js
1. `适配器模式`
将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
2. `桥接模式` //颜色和形状
思想：将两种不关联的属性进行分离，根据需要进行拼接。
将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体模式或接口模式。
`合成/聚合复用原则`：优先使用合成 / 聚合，而不是类继承
使用场景： 两个或多个同等级的接口
3. `组合模式`  //公司的职工和管理人员
又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。
使用场景：用于整体与部分的结构
4. `装饰模式`
功能：1. 增强原有的特性     2. 添加新的特性
5. `外观模式 `（门面模式）
将多个子系统封装起来，提供一个更简洁的接口供外部使用。
外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式。
6. `享元模式`
`程序可复用`
运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式。
7. `代理模式`
给某一个对象提供一个代理，并由代理对象控制对原对象的引用。
```
# 行为型模式     类和对象如何交互，及划分责任和算法。
```js
1. `责任链模式`  //合作解决不同难度的bug
使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
作用：处理职责相同，程度不同的类
优点： 1. 降低了对象之间的耦合度
      2. 扩展性强，满足开闭原则
      3. 灵活性强
      4. 责任分担
      5. 简化了对象之间的连接
2. `命令模式`  //智能家居
`宏命令`:将多个命令合并起来组成的命令。
使用场景：用于请求排队
优点如下：
        1. 降低系统的耦合度。将 “行为请求者” 和 ”行为实现者“ 解耦。
        2. 扩展性强。增加或删除命令非常方便，并且不会影响其他类。
        3. 封装 “方法调用”，方便实现 Undo 和 Redo 操作。
        4. 灵活性强，可以实现宏命令。
缺点：会产生大量命令类。增加了系统的复杂性。
3. `解释器模式`
给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。
使用场景：正则表达式
4. `迭代器模式`
提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。
`next() hasNext() `让外部遍历
使用场景:for-each 循环
5. `中介者模式`  //简化类与类之间的关系，多对多简化成一对多、一对一
定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。
6. 备忘录模式 //游戏中的存档
在不破坏封装的条件下，通过备忘录对象存储另外一个对象内部状态的快照，在将来合适的时候把这个对象还原到存储起来的状态。
优点：
    1. 给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便的回到某个历史的状态
    2. 实现了信息的封装，使得用户不需要关心状态的保存细节
缺点： 消耗资源，如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。
7. `观察者模式`
定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
`Observer``subscribe`
8. `状态模式`
当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
优点：将与特定状态相关的行为封装到一个状态对象中，使用多态代替 if-else 或者 switch-case 状态判断。
缺点：必然导致类增加，这也是使用多态不可避免的缺点。
9. `策略模式`
定义了一系列算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。
10. `模板方法模式` //请假、请假条
定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
`关于继承`
每一个被继承的父类都可以认为是一个模板，它的某些步骤是稳定的，某些步骤被延迟到子类中实现。
11. `访问者模式`
每一个被继承的父类都可以认为是一个模板，它的某些步骤是稳定的，某些步骤被延迟到子类中实现。
思想：将数据的结构和对数据的操作分离
程序在选择重载方法和重写方法时，如果两种情况都是动态分派的，则称之为 `双重分派`；
如果其中一种情况是动态分派，另一种是静态分派，则称之为 `单分派`。
```