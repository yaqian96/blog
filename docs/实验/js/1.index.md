---
title: js面试
date: 2021-07-27
categories:
  - react
tags:
  - 
---
# instanceof底层原理
```js
功能：
instanceof 运算符用于测试构造函数的 prototype 属性是否出现在对象原型链中的任何位置
function instance_of(left, right) {
  const RP = right.prototype; // 构造函数的原型
  while(true) {
    if (left === null) {
      return false;
    }
    if (left === RP) { // 一定要严格比较
      return true;
    }
    left = left.__proto__; // 沿着原型链重新赋值
  }
}
console.log(Number instanceof Number)  // false
console.log(String instanceof String)  // false
console.log(null instanceof Object)   // false
```
# typeof
```js
console.log(typeof undefined)  //'undefined'
console.log(typeof true)    //'Boolean'
console.log(typeof "abc")   //'string'
console.log(typeof 123)           //'number'
console.log(typeof function(){})  //'function'
console.log(typeof null)
console.log(typeof {})
console.log(typeof [])
console.log(typeof Symbol()) //'symbol'
console.log(typeof BigInt('1')) //'bigint'
判断对象与数组
1. instanceof 
2. constructor 
arr.constructor === Array 
3. Object.prototype.toString.call(a) === '[object Array]';//true  
4. Array.isArray()
`Object.prototype.toString与toString()的区别`：
Object.prototype.toString.call()
区别是：this绑定
每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”
```
# axios、fetch、ajax的区别
[axios、fetch、ajax](https://www.cnblogs.com/lyq1996/p/14485344.html)
```js
fetch()方法是暴露在全局作用域中的，包括主页面执行线程、模块和工作线程。调用这个方法，
浏览器就会向给定 URL 发送请求
```
# 如何实现 new 运算符
```js
1. 创建一个空对象，作为将要返回的实例对象。
2. 将这个空对象的原型，指向构造函数的prototype属性。
3. 将这个空对象赋值给函数内部的this关键字。
4. 开始执行构造函数内部的代码。
5. 如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。
// 参考js下的文件
let new2 = function(func) { 
  //创建一个空对象 o，并且继承构造函数的原型对象
  let o = Object.create(func.prototype);
  //执行构造函数，并且上下文 this 指向 o 对象
  let k = func.call(o);
  //如果构造函数返回的是对象就返回该对象，否则返回 o 对象
  if(typeof k === 'object') {
    return k
  }else {
    return o
  }
}
```
# arguments
arguments 是一个类似数组的对象, 对应于传递给函数的参数。
arguments对象是所有函数中可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。
```js
将 arguments 转换为真正的数组:
let args = Array.from(arguments);
let args = [...arguments];
```
```js
// 属性
1. arguments.callee 指向当前执行的函数。
2. arguments.caller 指向调用当前函数的函数。
3. arguments.length 指向传递给当前函数的参数数量。
```
# 图片懒加载、预加载
```js
图片预加载：就是在网页全部加载之前，提前加载图片，当用户需要查看时可直接从本地缓存中渲染，以提供给用户更好的体验，减少等待的时间。
图片懒加载（缓载）：延迟加载图片或符合某些条件时才加载某些图片。
懒加载的好处：
1. 能提升用户的体验
2. 减少无效资源的加载
3. 防止并发加载的资源过多会阻塞js的加载
1. 懒加载的实现
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Lazyload</title>
    <style>
      .image-item {
        display: block;
        margin-bottom: 50px;
        height: 200px; 
        /* 一定记得设置图片高度 */
      }
    </style>
  </head>
  <body>
    <img src="" class="image-item" lazyload="true" data-original="images/1.png" />
    <img src="" class="image-item" lazyload="true" data-original="images/2.png" />
    <img src="" class="image-item" lazyload="true" data-original="images/3.png" />
    <img src="" class="image-item" lazyload="true" data-original="images/4.png" />
    <img src="" class="image-item" lazyload="true" data-original="images/5.png" />
    <img src="" class="image-item" lazyload="true" data-original="images/6.png" />
    <img src="" class="image-item" lazyload="true" data-original="images/7.png" />
    <img src="" class="image-item" lazyload="true" data-original="images/8.png" />
    <img src="" class="image-item" lazyload="true" data-original="images/9.png" />
    <img src="" class="image-item" lazyload="true" data-original="images/10.png" />
    <img src="" class="image-item" lazyload="true" data-original="images/11.png" />
    <img src="" class="image-item" lazyload="true" data-original="images/12.png" />
    <script>
    // 方式一
      var viewHeight = document.documentElement.clientHeight//获取可视区高度
      function lazyload() {
        var eles = document.querySelectorAll('img[data-original][lazyload]')
        Array.prototype.forEach.call(eles, function (item, index) {
          var rect
          if (item.dataset.original === "")
            return
          rect = item.getBoundingClientRect()// 用于获得页面中某个元素的左，上，右和下分别相对浏览器视窗的位置
          if (rect.bottom >= 0 && rect.top < viewHeight) {
            !function () {
              var img = new Image()
              img.src = item.dataset.original
              img.onload = function () {
                item.src = img.src
              }
              item.removeAttribute("data-original")//移除属性，下次不再遍历
              item.removeAttribute("lazyload")
            }()
          }
        })
      }
      lazyload()//刚开始还没滚动屏幕时，要先触发一次函数，初始化首页的页面图片
      document.addEventListener("scroll",lazyload)
      // 方式二：echo.js

    </script>
  </body>
  </html>

2. 预加载
    1. 使用css进行图片预加载
    body:after {
        content: "";
        display: block;
        position: absolute;
        background: url("../image/...") no-repeat 0 0；
        height: 0
    }
    2. 使用css+js进行图片预加载
      .preload-img:after{
            content:"",
            background: url("../image/...") no-repeat 0 0；
        }
      $(function(){
          $("#img").addClass("preload-img")
      })
      // 另一种使用数组先保存图片，然后遍历查找值
    3. 使用ajax
    window.onload = function() {  
      setTimeout(function() {  
          // XHR to request a JS and a CSS  
          var xhr = new XMLHttpRequest();  
          xhr.open('GET', 'http://domain.tld/preload.js');  
          xhr.send('');  
          xhr = new XMLHttpRequest();  
          xhr.open('GET', 'http://domain.tld/preload.css');  
          xhr.send('');  
          // preload image  
          new Image().src = "http://domain.tld/preload.png";  
      }, 1000);  
    }; 
    4. 使用PreloadJS库
```
# 实现页面加载进度条
```js
1. h5的progress
2. 根据请求的返回的加载进度
```
# 手动实现 parseInt
```js
const _parseInt = (str, radix) => {
  // 不为string类型先转化为string 类型
  if (typeof str !== 'string') str = String(str)
  // 删除首尾空白
  str = str.trim()
  // 正则匹配[+|-]?[0]?[Xx]?[0-9a-fA-F]+
  const regex = /^(?<fuhao>[\+|\-]*)(?<radix>[0]?[Xx]?)(?<num>[0-9a-fA-F]+)/
  // 无法匹配返回NaN
  if (!regex.test(str)) return NaN
  // 匹配出符号、进制、数字三个分组
  const groups = str.match(regex).groups
  // radix的有效范围为 2-36
  if (radix && (radix < 2 || radix > 36)) return NaN
  // 如果没有指定radix, radix 会有以下默认值
  if (!radix) {
    if (groups.radix.toUpperCase() === '0X') radix = 16
    else if (groups.radix === '0') radix = 8
    else radix = 10
  }
  // 挨个字符串解析，如果遇到无法解析时则停止解析，返回已经解析好的整数
  let splitArr = groups.num.split('')
  const arr = []
  for(let i = 0; i < splitArr.length; i++) {
    // 根据charCode来做转行为实际数据, 0-9为[48-57],A-F为[65-70]
    const charCode = splitArr[i].toUpperCase().charCodeAt()
    let num 
    // 字符为[A-F]时, 实际数字为charCode -55
    if(charCode >= 65) num = charCode - 55
    // 字符为[0-9]时, 实际数字为charCode - 48
    else num = charCode - 48
    // 当实际数字大于radix时, 无法解析则停止字符串遍历
    if (num > radix) {
      break
    } else {
      arr.push(num)
    }
  }
  const len = arr.length
  // 当实际数字数组长度为0时, 返回NaN
  if(!len) return NaN
  let result = 0
  // 依次解析实际数字数组, 组合成真正的数字
  for(let i = 0; i < len; i++) {
    const num = arr[i] * Math.pow(radix, len - i - 1)
    result += num
  }
  // 算法匹配到的正负号
  return result * (groups.fuhao === '-' ? -1 : 1)
}

```
# 手写实现promise
[promise](https://www.cnblogs.com/lyq1996/p/14171617.html)
# call，apply，bind 三者用法和区别，原生实现 bind call apply
```js
call（this,arg1,arg2,arg3）
apply(this,[arg1,arg2])
bind(this,arg1,arg2)
bind不会立即调用，而是返回一个新函数，其中的this指向是创建bind的第一个参数，其他则会使用为参数。
1. bind
//可以修改函数this指向。
//bind返回一个绑定了this的新函数boundFcuntion，例子中我们用bound表示。
//支持函数柯里化，我们在返回bound函数时已传递了部分参数2，在调用时bound补全了剩余参数。
//boundFunction的this无法再被修改，使用call、apply也不行。
Function.prototype.bind_ = function (obj) {
    if (typeof this !== "function") {
        throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
    };
    var args = Array.prototype.slice.call(arguments, 1);
    var fn = this;
    //创建中介函数
    var fn_ = function () {};
    var bound = function () {
        var params = Array.prototype.slice.call(arguments);
        //通过constructor判断调用方式，为true this指向实例，否则为obj
        fn.apply(this.constructor === fn ? this : obj, args.concat(params));
    };
    fn_.prototype = fn.prototype;
    bound.prototype = new fn_();
    return bound;
};
2. call方法
Function.prototype._call = function(base, ...args) { // 拓展Function原型，使用Rest操作符接收剩余参数
    base = base || window; // 传递绑定的对象为null或undefined时指向window
    base.fn = this; // 调用_call时的this指向的是调用者也就是函数对象，将函数对象赋值给base对象的一个属性
    var result = base.fn(...args); // 调用base.fn时，fn中的this指针指向的是base，并使用Spread操作符展开参数传参
    delete base.fn; // 删除base对象的fn属性
    return result; // 将返回值返回
}
3. apply
Function.prototype._apply = function(base, args) { // 拓展Function原型
    base = base || window; // 传递绑定的对象为null或undefined时指向window
    base.fn = this; // 调用_apply时的this指向的是调用者也就是函数对象，将函数对象赋值给base对象的一个属性
    var result = base.fn(...args); // 调用base.fn时，fn中的this指针指向的是base，并使用Spread操作符展开参数传参
    delete base.fn; // 删除base对象的fn属性
    return result; // 将返回值返回
}
```
# 垃圾回收机制
```js
JavaScript 中的内存管理是自动执行的，而且是不可见的。
`可达性`
1. 有一组基本的固有可达值，由于显而易见的原因无法删除。例如:
本地函数的局部变量和参数
当前嵌套调用链上的其他函数的变量和参数
全局变量
还有一些其他的，内部的这些值称为根。
2. 如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的。
基本方法：
1. 标记清除法
标记根==>标记他们的引用以及子孙的引用==>不能访问的对象被认为是不可访问的，将被删除:
优化：
分代回收机制：新生代和老生代表。From和To两个空间。
增量回收
空闲时间收集
2. 引用计数
释放引用次数为0的值的内存
引用计数在代码中存在循环引用时会出现问题。
`内存管理`：
1. 通过 const 和 let 声明提升性能
2. 隐藏类和删除操作
3. `内存泄漏`
 ==================造成内存泄露的操作和内存泄露后的方法====================
 操作：1.  意外的全局变量
      2. 被遗忘的定时器或回调函数
      3. 脱离DOM的使用
      4. 闭包
方法： 1.  利用chorme的插件进行分析内存占用情况
      2. 在退出函数前将不使用的变量删除
      3. 避免变量的循环赋值和引用
      4. 静态分配与对象池
```
# 闭包
```js
闭包使用的场景
1. 定时器
2. 回调
3. 函数的防抖节流
4. 封装私有变量
5. 函数柯里化
6. 不使用循环返回数组
```
# 变量提升、函数提升
```js
1. 函数提升优于变量提升执行
2. 变量提升只提升声明，函数提升声明和赋值
3. 变量声明不会覆盖变量或函数的赋值
4. 函数声明会覆盖同名的变量声明和函数赋值，但不会覆盖变量赋值!
5. 立即执行函数(IIFE)中存在局部作用域，变量只会提升到函数内的顶部
```
# websocket的原理
```js
 缺点：会出现半死不活的状态。因为中间存在巨大的网络链路，导致会发生断点连接失败
 HTTP 1.1中的keep-alive connection是指在一次TCP连接上完成多次请求，但是对每个请求都要单独发header
 WebSocket 看成是 HTTP 协议为了支持长连接所打的一个大补丁。建立在TCP之上的。
 `websocket分为握手和数据传输阶段，即进行了HTTP握手 + 双工的TCP连接。`
 1. 握手阶段
 客户端发送消息：
  GET /chat HTTP/1.1
  Host: server.example.com
  Upgrade: websocket
  Connection: Upgrade
  Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
  Origin: http://example.com
  Sec-WebSocket-Version: 13
  服务端返回消息
  HTTP/1.1 101 Switching Protocols
  Upgrade: websocket
  Connection: Upgrade
  Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
  `Sec-WebSocket-Key`:Base64 encode
 2. 传输阶段
  frame形式传输的
  a、大数据的传输可以分片传输，不用考虑到数据大小导致的长度标志位不足够的情况。
  b、和http的chunk一样，可以边生成数据边传递消息，即提高传输效率。
  ![avatar](../images/websocket.webp)
  [参数参考](https://www.jianshu.com/p/3444ea70b6cb)
 3. 使用
 var socket;
  $("#connect").click(function(event){
      socket = new WebSocket("ws://127.0.0.1:8000/chat");
      socket.onopen = function(){
      alert("Socket has been opened");
      }
      socket.onmessage = function(msg){
      alert(msg.data);
      }
      socket.onclose = function() {
      alert("Socket has been closed");
      }
  });
  $("#send").click(function(event){
      socket.send("send from client");
  });
  $("#close").click(function(event){
      socket.close();
  })
```
# js的内置对象有哪些？
```js
1. 值属性：Infinity、NaN、null、undefined
2. 函数属性：eval()、parseFloat()、parseInt()
3. 基本对象：Object、Function、Boolean、Error
4. 数字和日期对象
5. 字符串
6. 可索引的集合对象
7. 使用键的集合对象
8. 矢量集合
9. 结构化数据，如JSON
10. Promise、Reflect、Proxy
11. arguments
```
# 继承
```js
1. 原型链继承
注意：通过此方法继承时，不能使用对象字面量创建原型方法，因为会重写原型链。
缺点：1.引用类型的原型共用，会影响所有的实例。2.构建实例时，不能向里边传入参数。不能与构造函数一样。
2. 借用构造函数继承 (经典继承)
思路：在子类构造函数中调用父类构造函数。
function Person(name){
  this.name=name;
}
function Second(){
  //即传入参数，又定义自己的属性
Person.call(this,'qwqw')
this.age=12;
}
let s=new Second();
console.log('s.name',s.name);
console.log('s.age',s.age);
缺点：方法都在构造函数中定义，函数不能复用。
3. 组合继承
思路：使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性
4. 原型式继承
思想：实现对象之间的信息共享
    // function object(o){
    //   function F(){};
    //   F.prototype=o;
    //   return new F();
    // }
    var person={
      name:'ssss',
      friends:['k','l','o']
    }
    var another=Object.create(person,{
      name:{
        value:"SSS"
      }
    });
    alert(another.name)  //SSS
5. 寄生式继承
思路：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。
function createAnother(original){ 
 let clone = object(original); // 通过调用函数创建一个新对象
 clone.sayHi = function() { // 以某种方式增强这个对象
   console.log("hi"); 
 }; 
 return clone; 
}// 返回这个对象
======使用=======
let person = { 
 name: "Nicholas", 
 friends: ["Shelby", "Court", "Van"] 
};
let anotherPerson = createAnother(person); 
anotherPerson.sayHi(); // "hi"
}
缺点：
6. 寄生式组合继承
function inheritPrototype(subType, superType) { 
 let prototype = object(superType.prototype); // 创建对象
 prototype.constructor = subType; // 增强对象 
 subType.prototype = prototype; // 赋值对象
}
function SuperType(name) { 
 this.name = name; 
 this.colors = ["red", "blue", "green"]; 
} 
SuperType.prototype.sayName = function() { 
 console.log(this.name); 
}; 
function SubType(name, age) { 
 SuperType.call(this, name); 
 this.age = age; 
} 
inheritPrototype(SubType, SuperType); 
SubType.prototype.sayAge = function() { 
 console.log(this.age); 
};。
7. ES6继承
class Parent{
    constructor(name){
        this.name = name
    }
    getName(){
        return this.name
    }
}

class Son extends Parent{
    constructor(name, age){
        super(name)
        this.age = age
        console.log(new.target)
    }
    introduce(){
        return `我叫做${this.name}，今年${this.age}岁了`
    }
}
const s = new Son("小李", 8)
console.log(s.introduce()) // 我叫做小李，今年8岁了
console.log(s.getName()) // 小李
```
# 原型和原型链
```js
`原型`
js中的对象，都有其对应的prototype属性，其中包含共享的属性和方法。
`原型链`
每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味
着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函
数。这样就在实例和原型之间构造了一条原型链。
```
# 观察者模式，和发布订阅模式，有什么区别？
```js
1. 观察者模式：实现松耦合(loosely coupled)
观察者模式里面，changed()方法所在的实例对象，就是被观察者（Subject，或者叫Observable），它只需维护一套观察者（Observer）的集合，这些Observer实现相同的接口，Subject只需要知道，通知Observer时，需要调用哪个统一方法就好了：
![avatar](../images/观察者与发布订阅模式的区别.jpg)
```
# valueOf() toString()
{}的valueof()结果是{},toString的结果是[Object object]
[] 的valueof()结果是[],toString的结果是’’
```js
toString()方法：返回对象的字符串表示。
console.log('222'.toString())    // '222'
console.log((222).toString())           // '222'
0.toString();//Uncaught SyntaxError: Invalid or unexpected token
console.log({name:'22'}.toString())   // '[object Object]'
console.log(true.toString())     //'true'
console.log([1,3,4].toString())  //1 ,3,4
console.log(function(){alert('eee')}.toString())  //'function(){alert('eee')'
console.log(new Error('错误').toString())  //'Error: 错误'
console.log(new Date().toString())  //Wed Jul 28 2021 15:58:46 GMT+0800 (中国标准时间)
Date.toString();//"function Date() { [native code] }"
String.toString(); //"function String() { [native code] }"
RegExp.toString();//"function RegExp() { [native code] }"
========================================================================
valueOf()方法：返回指定对象的原始值
console.log('222'.valueOf())    // '222'
console.log((222).valueOf())           // 222
//0.valueOf();//Uncaught SyntaxError: Invalid or unexpected token
console.log({name:'22'}.valueOf())   // {name:'22'}
console.log(true.valueOf())     //true
console.log([1,3,4].valueOf())  //[1, 3, 4]
console.log(function(){alert('eee')}.valueOf())  //'function(){alert('eee')'
console.log(new Error('错误').valueOf())  //'Error: 错误'
console.log(new Date().valueOf())  //1627459767493
console.log(Date.valueOf())
Date.valueOf();//function Date() { [native code] }
String.valueOf(); //function String() { [native code] }
RegExp.valueOf();//function RegExp() { [native code] }
共同点：在 JavaScript 中，toString()方法和valueOf()方法，在输出对象时会自动调用。
不同点：二者并存的情况下，在数值运算中，优先调用了valueOf，字符串运算中，优先调用了toString。
共同的缺点：无法获取null和undefined的值
```
# tofixed()的原理
```js
四舍六入五成双:“四”是指≤4 时舍去，"六"是指≥6时进上，"五"指的是根据5后面的数字来定，当5后有数时，舍5入1；当5后无有效数字时，需要分两种情况来讲：①5前为奇数，舍5入1；②5前为偶数，舍5不进。（0是偶数）
function fixed(num, digits){
   let dig = Math.pow(10, digits);
   return Math.round(num * dig) / dig; //Math.round采用四舍五入的方法
}
```

# 作用域
```js
1. 全局作用域 ----global/window
全局变量拥有的作用域
在函数内部或代码块中没有定义的变量实际上是作为 window/global 的属性存在，而不是全局变量。
2. 函数作用域 ---- 'function'
在函数内部定义的局部变量所拥有的作用域，外部只能通过return 或者闭包访问到
3. 块级作用域 ---- {}
let
4. 动态作用域 ----this
this根据调用的不同，指向不同
```
# TCP UDP区别
TCP:
1. 面向连接
2. 仅支持单播传输
3. 面向字节流
4. 可靠传输
5. 提供拥塞控制
6. TCP提供全双工通信
UDP:
1. 面向无连接
2. 有单播，多播，广播的功能
3. UDP是面向报文的
4. 不可靠性
# 箭头函数能当做构造函数？箭头函数的this?
箭头函数的this是指向父级的，本身没有this
# 客户端存储
```js
1. `cookie`最初用于在客户端存储会话信息，不可跨域名性
服务器在响应HTTP 请求时，通过发送 Set-Cookie HTTP 头部包含会话信息。
cookie的组成：名称、值、域、路径、过期时间、安全标志。
document.cookie 可获取所有的cookie字符串
`子cookie`:单个cookie 存储的小块数据，本质上是使用 cookie 的值在单个 cookie 中存储多个名/值对
`Cookie机制`是通过检查客户身上的“通行证”来确定客户身份
2. Web Storage
  2.1 localStorage 永久存储机制
  2.2 sessionStorage 跨会话的存储机制
  `Session机制`是服务器端使用的一种记录客户端状态的机制。
3. IndexedDB 
使用对象存储而不是表格保存数据。异步请求
```
[cookie、session](https://www.cnblogs.com/l199616j/p/11195667.html)

# this
this:是一个对象，函数执行的上下文对象。指代函数当前的运行环境
```js
谁调用，函数就指向谁。
情况一：普通函数调用，则指向全局window。在非严格模式下this就是window，严格模式下是undefined
       匿名函数的this,指的是window
情况二：对象调用，则指向对象
情况三：构造函数使用，则指向实例
情况四：箭头函数中的this,指的是父级的上下文
情况五：apply、call、bind改变this的指向
情况六：事件中使用this,则表示事件绑定的元素DOM
`new.target`:检测函数是否使用 new 关键字调用的 new.target 属性
```
# 数据类型
```js
6种简单数据类型：Undefined、Null、Boolean、Number、String 和 Symbol、bigInt（指安全存储、操作大整数）
let sym = Symbol(); 
console.log(typeof sym); // symbol
注意：1. Symbol不能用for...in或者for..of循环
     2. 可以通过 Object.getOwnPropertySymbols() 和 Reflect.ownKeys() 取到
     3. 使用[]取值
     4. Symbol.for()和Symbol.keyFor()方法
引用数据类型：Object
```
# 数组的方法（ES6、ES5）
```js
空位的处理
ES5 `forEach() , filter() , every() 和 some() 都会跳过空位。
map() 会跳过空位，但会保留这个值
join() 和 toString() 会将空位视为 undefined ，而 undefined 和 null 会被处理成空字符串。`
ES6 则是明确将空位转为 undefined 。
改变数组的方法：
1. pop push
2. shift unshift
3. reverse
4. sort 
5. splice
6. [1, 2, 3, 4, 5].copyWithin(0, 3)    在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。
7. arr.fill(target, start, end) 使用给定的值，填充一个数组
不会改变数组的方法：
1. forEach
2. map
forEach、map的区别：
     1. map有返回值，forEach没有返回值，返回结果为undefined(没有return)
     2. forEach()会跳过空值，但是map会跳过空值，但是会保留这个值
     3. forEach无法中途跳出循环,break或return都不能奏效
3. filter
4. every
5. some
6. reduce
7. reduceRight
8. indexOf 、lastIndexOf
9. Array.from()  ----es6
10. Array.of() 将一组值转换成数组，类似于声明数组    ---es6
11. arr.find(callback) 找到第一个符合条件的数组成员
12. arr.findIndex(callback) 找到第一个符合条件的数组成员的索引值
13. arr.includes() 判断数中是否包含给定的值
14. entries()，keys()和values()
15. slice()
16. concat
```
# ES6的新知识
```js
1. Set  WeakSet
它类似于数组，但是成员的值都是唯一的，没有重复的值。Set本身是一个构造函数，用来生成Set数据结构。
   const s=new Set();
   s.add()
   s.size 判断长度
   delete(value) ：删除某个值，返回一个布尔值，表示删除是否成功。
   has(value) ：返回一个布尔值，表示该值是否为 Set 的成员。
   clear() ：清除所有成员，没有返回值。
   遍历操作：keys() values() entries() forEach()
WeakSet的区别：
第一个：WeakSet的成员只能是对象，而不能是其他的值。
第二个：WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象。那么垃圾回收机制会自动会输该对象所占用的额内存，不考虑该对象还存在与WeakSet之中。
   size  没有size属性，没有办法遍历它的成员。无法清空
   用处：存储DOM节点
2. Map、WeakMap
它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。
    size
    set(key, value)
    get(key)
    has(key)
    delete(key)
    clear()
    遍历操作：keys() values() entries() forEach()
WeakSet:
唯一的区别是它只接受对象作为键名（ null 除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。
3. 箭头函数
   1. 不能当做构造函数
   2. 没有arguments
   3. 没有super
   4. 没有原型
   5. 没有new.target
   6. 没有this
4. let const var的区别
   1. let const不允许在相同作用域内，重复声明同一个变量
   2. const声明一个只读的常量，常量的值就不能改变，但是针对对象，就是可改变的。
5. for...of
   使用的范围：数组、Set 和 Map 结构、某些类似数组的对象（比如 arguments 对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。
   普通对象，不能直接使用for..of
6. proxy
7. es6 以及相关的模块化理解
AMD(异步模块定义)===>require.js===>用于浏览器端
CommonJS===>node===>用于服务器端
CMD模块定义规范===>Sea.js
 CommonJS与ES6 module区别：
   1. CommonJS是值的拷贝，ES6是值的引用
   2. CommonJS是运行时加载，ES6是编译时输出接口
   3. CommomJS是require()同步加载模块，ES6的import是异步加载
  ES6 module
  1. 'import export'
  2. 采用单例模式，重复的模块只执行一次
  3. 自动采用严格模式，模块之中，顶层的 this 关键字返回 undefined ，而不是指向 window 。
8. class
  1. 在class中声明方法其实就是声明在原型上，类本身就是指向构造函数，类里面定义的方法都是不可枚举的。this指向类的实例。
  class Person {
    // 静态属性
    static x = 0;
    constructor() {
      this._x=0;//私有属性
			this.y=0;//公有属性
    }
    toString(){
      console.log('parent toString method');
    }
    //私有方法
    _printName(){
      this.toString()
    }
    * add(){
      for(let i =0;i<10;i++) {
        yield i;
      }
    }
  }
  2. class的继承
    class ColorPoint extends Point {}
    1. ES5的继承，实质是先创造子类的实例对象 this ，然后再将父类的方法添加到 this 上面（ Parent.apply(this) ）。ES6的继承机制完全不同，实质是先创造父类的实例对象 this （所以必须先调用 super 方法），然后再用子类的构造函数修改 this 。
    2. 
    class A { }
    class B extends A { }
    B.__proto__ === A // true
    B.prototype.__proto__ === A.prototype // true
    3. Object.getPrototypeOf 方法可以用来从子类上获取父类。
  3. super
    1. 既可以当作函数使用，也可以当作对象使用.
    2. 通过 super 调用父类的方法时， super 会绑定子类的 this 。
    3. 如果 super 作为对象，用在静态方法之中，这时 super 将指向父类，而不是父类的原型对象。
9. 函数式编程
   1. 柯里化
   2. 函数合成
   3. 参数倒置（flip）:改变函数前两个参数的顺序。
   4. 执行边界（until）指的是函数执行到满足条件为止
   5. 队列操作 head last tail init
   6. 合并操作 concat concatMap
   7. 配对操作 zip zipWith
10. Reflect
    可以操作对象的API
    Reflect.apply(target,thisArg,args)
    Reflect.construct(target,args)
    Reflect.get(target,name,receiver)
    Reflect.set(target,name,value,receiver)
    Reflect.defineProperty(target,name,desc)
    Reflect.deleteProperty(target,name)
    Reflect.has(target,name)
    Reflect.ownKeys(target)
    Reflect.isExtensible(target)
    Reflect.preventExtensions(target)
    Reflect.getOwnPropertyDescriptor(target, name)
    Reflect.getPrototypeOf(target)
    Reflect.setPrototypeOf(target, prototype)
11. promise
   1. Pending （进行中）、 Resolved （已完成，又称 Fulfilled）和 Rejected （已失败）。
   2. 对象的状态不受外界影响。
   3. 一旦状态改变，就不会再变，任何时候都可以得到这个结果
   4. 缺点：无法取消promise,一旦新建它就会立即执行，无法中途取消
   Promise对象是一个构造函数。
    var promise = new Promise(function(resolve, reject) {
    // ... some code
    if (/* 异步操作成功 */){
    resolve(value); //从Pending变为Resolved
    } else {
    reject(error); //从Pending变为Rejected
    }
    });
    promise.then(function(value) {
    // success   resolved的回调函数
    }, function(error) {
    // failure  rejected的回调函数
    });
    API
    Promise.prototype.then()
    Promise.prototype.catch() //.then(null, rejection) 的别名，
    Promise.all()  //只有所有的promise状态都变成 fulfilled,状态才会变成 fulfilled,并返回数组。如果有一个为rejected,则返回第一个rejected的值
    Promise.race() //之中有一个实例率先改变状态， p 的状态就跟着改变
    Promise.resolve() 
    1. 参数是一个Promise实例  //返回这个实例
    2. 参数是一个 thenable 对象 //会立即执行thenable对象的then方法
    3. 参数不是具有 then 方法的对象，或根本就不是对象 //返回一个新的promise对象，状态为resolved
    4. 不带有任何参数  //返回一个 Resolved 状态的Promise对象
    Promise.reject() //会原封不动地作为 reject 的理由，变成后续方法的参数
    Promise.try()   //不知道或者不想区分，函数 f 是同步函数还是异步操作，但是想用 Promise 来处理它
    done() //于回调链的尾端，保证抛出任何可能出现的错误
    finally() //不管Promise对象最后状态如何，都会执行的操作
  使用场景：
  1. axios、fetch中的promise
  2. 加载图片
  `如何在外部修改promise的状态`
  解决方法：在promise外部通过地址引用的方式进行改变promise内部状态是可以实现的。
  `JS实现一个带并发限制的异步调度器Scheduler，保证同时运行的任务最多有两个，`
  const timeout = (time) => new Promise(resolve => {
    setTimeout(resolve, time)
  });
  class Scheduler {
      constructor() {
          this.awaitArr = [];
          this.count = 0;
      }
      async add(promiseCreator) {
          if (this.count >= 2) {
              await new Promise(resolve => {
                  this.awaitArr.push(resolve);
              });
          }
          this.count++;
          const res = await promiseCreator();
          this.count--;

          if (this.awaitArr.length) {
              this.awaitArr.shift()();
          }
          return res;
      }
  }
  const scheduler = new Scheduler()
  const addTask = (time, order) => {
      scheduler.add(() => timeout(time))
          .then(() => console.log(order))
  }
  addTask(1000, '1000')
  addTask(500, '500')
  addTask(400, '400')
  addTask(300, '300')
  // 500 400 1000 300
12. async
   1. async 表示函数里有异步操作,await 命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）
   2. async返回的值是promise
   3. async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数
```
# this的指向问题
```js
var num1=1;
var num2=2;
function cal(){
  var num1=10,num2=20;
  console.log(this.num1+this.num2)
}
new cal()  //NAN
cal()    //3
var callbind=cal.bind({num1=100,num2=200}) //报语法错误
```
# 使用vue自定义指令实现图片的懒加载
```js
IntersectionObserver API
import img from "@/assets/logo.png";
let timer = null; // 创建一个监听器
let observer = new IntersectionObserver((entries) => {
  // entries是所有被监听对象的集合
  entries.forEach((entry) => {
    if (entry.isIntersecting || entry.intersectionRatio > 0) {
      // 当被监听元素到临界值且未加载图片时触发。
      !entry.target.isLoaded && showImage(entry.target, entry.target.data_src);
    }
  });
});
function showImage(el, imgSrc) {
  const img = new Image();
  img.src = imgSrc;
  img.onload = () => {
    el.src = imgSrc;
    el.isLoaded = true;
  };
}
export default {
  // 这里用inserted和bind都行，因为IntersectionObserver时异步的，以防意外还是用inserted好一点  // inserted和bind的区别在于inserted时元素已经插入页面，能够直接获取到dom元素的位置信息。
  inserted(el, binding, vnode) {
    clearTimeout(timer); // 初始化时展示默认图片
    el.src = img; // 将需要加载的图片地址绑定在dom上
    el.data_src = binding.value;
    observer.observe(el);
    // 防抖，这里在组件卸载的时候停止监听
    const vm = vnode.context;
    timer = setTimeout(() => {
      vm.$on("hook:beforeDestroy", () => {
        observer.disconnect();
      });
    }, 20);
  }, // 图片更新触发
  update(el, binding) {
    el.isLoaded = false;
    el.data_src = binding.value;
  },
};
Vue.directive("image", image);
<div v-for="(item, index) in imgSrc" :key="index">
  <img v-image="item" />
</div>
`使用原生js实现图片的懒加载`
var imgs = document.querySelectorAll('img');
//用来判断bound.top<=clientHeight的函数，返回一个bool值
function isIn(el) {
    var bound = el.getBoundingClientRect();
    var clientHeight = window.innerHeight;
    return bound.top <= clientHeight;
} 
//检查图片是否在可视区内，如果不在，则加载
function check() {
    Array.from(imgs).forEach(function(el){
        if(isIn(el)){
            loadImg(el);
        }
    })
}
function loadImg(el) {
    if(!el.src){
        var source = el.dataset.src;
        el.src = source;
    }
}
window.onload = window.onscroll = function () { //onscroll()在滚动条滚动的时候触发，采用节流
    check();
}
```
# 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.
与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).
```js
var threeSumClosest = function(nums, target) {
    if (nums.length <= 3) {
        return nums.reduce(function(prev, curr){
            return prev + curr;
        });
    }
    nums.sort(function(a, b){
        return a-b;
    })

    var left,right;
    var diff = target - nums[0] - nums[1] - nums[2];
    var sum;

    for (var i=0; i<nums.length; i++) {
        left = i + 1;
        right = nums.length - 1;
        while(left < right) {
            sum = nums[i] + nums[left] + nums[right]
            if (Math.abs(diff) > Math.abs(target - sum)) {  //注意这里对比的是绝对值
                diff = target - sum;
            }
            if (diff === 0) return target;  //相加等于target，此时直接返回
            if (target - sum > 0) {
                left++;
            } else {
                right--;
            }
        }
    }

    return target - diff;
};
```