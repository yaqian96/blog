---
title: vue的相关
date: 2021-07-14 
categories:
  - vue
tags:
  - vue
---
# 1. vue的data为啥是一个函数而不是对象
```js
  //原理分析：
  针对根实例对象data, data对象既可以是对象也可以是函数。
  ----------------------------------------------------
  组件实例对象data必须为函数，目的是为了防止多个组件实例对象之间共用一个data，产生数据污染。
  采用函数的形式，initData时会将其作为工厂函数都会返回全新data对象。
  --------------------------------------------------
  data为函数 (针对实例对象)，通过return 返回对象的拷贝，从而开辟一个新的空间地址，致使每个实例都有自己独立的对象，数据改变时也只是在自己的作用域改变，而实例之间是不会相互影响的。
  // vue/src/core/instance/state.js
  function initData (vm: Component) {
    var data = vm.$options.data;
    data = vm._data = typeof data === 'function'
      ? getData(data, vm)
      : data || {};
    if (!isPlainObject(data)) {
      data = {};
      process.env.NODE_ENV !== 'production' && warn(
        'data functions should return an object:\n' +
        'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
        vm
      );
    }
    ...
  }
  // vue/src/core/util/options.js
   strats.data = function (
    parentVal: any,
    childVal: any,
    vm?: Component
  ): ?Function {
    if (!vm) {
      if (childVal && typeof childVal !== 'function') {
        process.env.NODE_ENV !== 'production' && warn(
          'The "data" option should be a function ' +
          'that returns a per-instance value in component ' +
          'definitions.',
          vm
        )
        return parentVal
      }
      return mergeDataOrFn(parentVal, childVal)
    }
    return mergeDataOrFn(parentVal, childVal, vm)
  }
  --------------------------------------------------
  babel编译的组件对象，会造成变量相互引用。
  我们的每一个vue文件经过babel编译，将导出的对象直接替换成了一个对象变量，然后将这个变量传入到对应的组件构造函数中
```
# 2. v-if和v-for的层级
```js
1. 当v-if在外层时，v-for的优先级就会比v-if的要高
2. 同级
2.x 版本中在一个元素上同时使用 v-if 和 v-for 时，v-for 会优先作用。
3.x 语法,v-if 总是优先于 v-for 生效。
```
# 3.v-if和v-show的区别
```js
1. v-show 只是简单的控制元素的 display 属性，而 v-if 才是条件渲染（条件为真，元素将会被渲染，条件为假，元素会被销毁）；
2.  v-show 有更高的首次渲染开销，而 v-if 的首次渲染开销要小的多；
3. v-if 有更高的切换开销，v-show 切换开销小；
4. v-if 有配套的 v-else-if 和 v-else，而 v-show 没有
5. v-if 可以搭配 template 使用，而 v-show 不行
总结：如果要频繁切换某节点，使用v-show(切换开销比较小，初始开销较大)。如果不需要频繁切换某节点使用v-if（初始渲染开销较小，切换开销比较大）。
```
# 4.v-model
答：v-model用于表单数据的双向绑定，其实它就是一个语法糖，这个背后就做了两个操作：
v-bind绑定一个value属性；
v-on指令给当前元素绑定input事件
# 5.分别简述computed和watch的使用场景
答：computed:
　　　　当一个属性受多个属性影响的时候就需要用到computed,有缓存
　　　　最典型的栗子： 购物车商品结算的时候
watch:
　　　　当一条数据影响多条数据的时候就需要用watch
　　　　栗子：搜索数据
# 6.assets和static的区别
```js
区别：assets中存放的静态资源文件在项目打包时，也就是运行npm run build时会将assets中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在static文件中跟着index.html一同上传至服务器。
static中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器
建议：将项目中template需要的样式文件js文件等都可以放置在assets中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如iconfoont.css等文件可以放置在static中，因为这些引入的第三方文件已经经过处理，我们不再需要处理，直接上传。
```
# 7. vue的的通信方式
```js
`父子之间相互`
$emit props $refs、$parent 、$children
在子组件中没有声明 props 进行接收的那些属性会被包含在 attrs 中。
<children v-bind="$attrs"></children> //说的就是可以通过 v-bind="$attrs" 把 这些属性绑定到其他的节点上（包括子节点，是祖孙组件传值的技术基础）
<children v-bind="$listeners"></children> //$listeners 是个 Object。包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on="$listeners" 传入内部组件。
兄弟之间：
1. 父组件中转
2. bus中央事件总线
Bus.$emit("zifu", this.a++, "子组件向兄弟组件传值");
Bus.$on("zifu", (val, val1) => {    //取  Bus.$on
      this.ccc = val;
      this.ddd = val1;
    });
`跨级之间`： provide / inject 依赖注入可以跨层级传参 、EventBus

`Vue事件总线EventBus`: 所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件
使用：
1. 新创建一个js文件 或者在main.js中初始化Vue.prototype.$EventBus = new Vue()
import Vue from 'vue'
export const EventBus = new Vue()
2. 
// 发送消息
EventBus.$emit(channel: string, callback(payload1,…))
// 监听接收消息
EventBus.$on(channel: string, callback(payload1,…))
缺点：刷新EventBus移除
原理：发布/订阅方法
```
# 8.vue设计中使用的设计模式？
```js
观察者模式
```
# 9. 双向绑定
# 10.函数化组件
使用场景：
需要通过编程实现在多种组件中选择一种。
children、props 或者 data 在传递给子组件之前，处理它们。

