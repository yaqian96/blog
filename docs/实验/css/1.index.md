---
title: css面试
date: 2021-08-18
categories:
  - css
tags:
  - 
---
# 0.css中的行内元素、块级元素
```js
1. inline元素 （span、img、a、lable、input、abbr（缩写）、em（强调）、big、cite（引用）、i（斜体）、q（短引用）、textarea、select、small、sub、sup，strong、u（下划线）、button（默认display：inline-block）
特点:
和其他元素都在一行上；
元素的高度、宽度、行高及顶部和底部边距不可设置,可设置行高。
元素的宽度就是它包含的文字或图片的宽度，不可改变。
2. block元素 （div、p、h1…h6、ol、ul、dl、table、address、blockquote、form）
每个块级元素都从新的一行开始，并且其后的元素也另起一行。（一个块级元素独占一行）;
元素的高度、宽度、行高以及顶和底边距都可设置;
元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。
3. inline-block元素 （img、input）
和其他元素都在一行上；
元素的高度、宽度、行高以及顶和底边距都可设置
```
# 1.介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？
```js
盒模型都是由四个部分组成的，分别是margin、border、padding和content。

标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同。标准盒模型的width和height属性的
范围只包含了content，而IE盒模型的width和height属性的范围包含了border、padding和content。

一般来说，我们可以通过修改元素的box-sizing属性来改变元素的盒模型。
`如果在ie6，7，8中DOCTYPE缺失会将盒子模型解释为IE盒子模型。若在页面中声明了DOCTYPE类型，所有的浏览器都会把盒模型解释为W3C盒模型。`
```
# 2.CSS 选择符有哪些？
```js
（1）id选择器（#myid）
（2）类选择器（.myclassname）
（3）标签选择器（div,h1,p）
（4）后代选择器（h1p）
（5）相邻后代选择器（子）选择器（ul>li）
（6）兄弟选择器（li~a）
（7）相邻兄弟选择器（li+a）
（8）属性选择器（a[rel="external"]）
（9）伪类选择器（a:hover,li:nth-child,target）
（10）伪元素选择器（::before、::after）
（11）通配符选择器（*）
```
# 3.::before 和:after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用。
```js
单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）
双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，
比如:first-line、:first-letter、:before、:after等，
而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。
```
# 4.伪类与伪元素的区别
```js
  http://www.alloyteam.com/2016/05/summary-of-pseudo-classes-and-pseudo-elements/
 css引入伪类和伪元素概念是为了格式化文档树以外的信息。
 `伪类` :状态类：（LVHAF）结构化（:not :first-child :first-of-type :nth-child :nth-of-type :target ）
 `伪元素`： ::before ::after ::first-letter ::first-line ::selection ::placeholder ::backdrop
```
# 5.CSS 中哪些属性可以继承？
```js
有继承性的属性：
（1）字体系列属性
font、font-family、font-weight、font-size(属于子继承)、font-style、font-variant、font-stretch、font-size-adjust
（2）文本系列属性
text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、
text-transform、direction、color
（3）表格布局属性
caption-sideborder-collapseempty-cells
（4）列表属性
list-style-type、list-style-image、list-style-position、list-style
（5）光标属性
cursor
（6）元素可见性
visibility
（7）还有一些不常用的；speak，page，设置嵌套引用的引号类型quotes等属性
// 关系
”important>内联 >ID>类 >标签 |伪类|属性选择 >伪对象 >继承 >通配符”
// 继承css3
all: [ inherit | initial | unset ]: 
```
# 6.CSS 优先级算法如何计算？
```js
1. 继承不如指定
2. !important > 内联 > ID > Class|属性|伪类 > 元素选择器
3. :link、:visited、:hover、:active按照LVHA（LoVe HAte）顺序定义
继承样式优先级最低
```
# 7.关于伪类 LVHA 的解释?
```js
a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:link、:visited、:hover、:active；

当链接未访问过时：
（1）当鼠标滑过a链接时，满足:link和:hover两种状态，要改变a标签的颜色，就必须将:hover伪类在:link伪
类后面声明；
（2）当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active），
必须将:active声明放到:link和:hover之后。因此得出LVHA这个顺序。

当链接访问过时，情况基本同上，只不过需要将:link换成:visited。

这个顺序能不能变？可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，
也就不存在覆盖的问题。
```
# 8.CSS3 新增伪类有那些？
```js
（1）elem:nth-child(n)选中父元素下的第n个子元素，并且这个子元素的标签名为elem，n可以接受具体的数
值，也可以接受函数。
（2）elem:nth-last-child(n)作用同上，不过是从后开始查找。
（3）elem:last-child选中最后一个子元素。
（4）elem:only-child如果elem是父元素下唯一的子元素，则选中之。
（5）elem:nth-of-type(n)选中父元素下第n个elem类型元素，n可以接受具体的数值，也可以接受函数。
（6）elem:first-of-type选中父元素下第一个elem类型元素。
（7）elem:last-of-type选中父元素下最后一个elem类型元素。
（8）elem:only-of-type如果父元素下的子元素只有一个elem类型元素，则选中该元素。
（9）elem:empty选中不包含子元素和内容的elem类型元素。
（10）elem:target选择当前活动的elem元素。
（11）:not(elem)选择非elem元素的每个元素。
（12）:enabled    控制表单控件的禁用状态。
（13）:disabled        控制表单控件的禁用状态。
 (14):checked单选框或复选框被选中。
```
# 9.CSS 实现元素水平垂直居中的 N 种方式
```js
1. 水平居中
   1.1 行内元素
   其父元素设置 text-align:center
   1.2 块级元素
   1.2.1 宽高固定
        方式一：margin:0 auto
        方式二：absolute + margin-left
        .child {
          position: absolute;
          margin-left: -50px;
          left: 50%;
        }
        方式三：absolute + calc
        position: absolute;
        left: calc(50% - 50px);
        方式四：absolute + left + right + margin-left
          position: absolute;
          left: 0;
          right: 0;
          margin: 0 auto;
   1.2.2 宽高不固定
   方式一：使用 CSS3 中新增的 transform 属性
   .child {
    position: absolute;
    left: 50%;
    transform:translate(-50%, 0);
  }
  方式二：flex 布局
  方式三：width: fit-content
   .child {
    width: fit-content;
    margin: 0 auto;
  }
2. 垂直居中
2.1 行内元素
方式一：line-height（单行文本）
方式二：display: table-cell + vertical-align  (多行文本)
  .parent {
    display: table;
  }
  .child {
    display: table-cell;
    vertical-align: middle;
  }
方式三：display: inline-block + vertical-align 隐式幽灵节点
  .parent {
    line-height: 100px; /* 通过 line-height 设置幽灵节点的基线 */
  }
  .child {
    vertical-align: middle;
    line-height: normal; /* 块级元素时需要加 */
    display: inline-block; /* 重点，要把 line-height 设置成 normal, 要不然会继承100 */
  }
方式四：display: grid 布局
.parent {
  display: grid;
}
.child {
  margin: auto;
}
方式五：writing-mode 布局
.parent {
  writing-mode: vertical-lr;
}
.child {
  writing-mode: horizontal-tb;
}
2.2 块级
2.2.1 宽高固定
方式一：absolute + margin-top
.child {
    position: absolute;
    margin-left: -25px;
    left: 50%;
    margin-top: -25px;
    top: 50%;
}
方式二：absolute + calc
.child {
    position: absolute;
    left: calc(50% - 25px);
    top: calc(50% - 25px);
  }
方式三：absolute + left + right + top + bottom
.child {
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    margin: auto;
  }
2.2.2 宽高不固定
方式一：使用 CSS3 中新增的 transform 属性
.child {
    position: absolute;
    left: 50%;
    top: 50px;
    transform: translate(-50%, -50%);
  }
方式二：flex 布局
方式三：利用text-align:center和vertical-align:middle属性
.container {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background: rgba(0, 0, 0, 0.5);
  text-align: center;
  font-size: 0;
  white-space: nowrap;
  overflow: auto;
}
.container::after {
  content: "";
  display: inline-block;
  height: 100%;
  vertical-align: middle;
}
.box {
  display: inline-block;
  width: 500px;
  height: 400px;
  background-color: pink;
  white-space: normal;
  vertical-align: middle;
}
```
# 10.display 有哪些值？说明他们的作用。
```js
block    块类型。默认宽度为父元素宽度，可设置宽高，换行显示。
none    元素不显示，并从文档流中移除。
inline    行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。
inline-block默认宽度为内容宽度，可以设置宽高，同行显示。
list-item    像块类型元素一样显示，并添加样式列表标记。
table    此元素会作为块级表格来显示。
inherit    规定应该从父元素继承display属性的值。
```
# 11.position 的值 relative 和 absolute 定位原点是？
```js
absolute
生成绝对定位的元素，相对于值不为static的第一个父元素的paddingbox进行定位，也可以理解为离自己这一级元素最近的
一级position设置为absolute或者relative的父元素的paddingbox的左上角为原点的。
fixed（老IE不支持）
生成绝对定位的元素，相对于浏览器窗口进行定位。
relative
生成相对定位的元素，相对于其元素本身所在正常位置进行定位。
static
默认值。没有定位，元素出现在正常的流中（忽略top,bottom,left,right,z-index声明）。
inherit
规定从父元素继承position属性的值。
```
# 12.请解释一下 CSS3 的 Flexbox（弹性盒布局模型），以及适用场景？
```js
// 设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。
```
# 13. dispaly:inline-block与float的区别
```js
1. 相同点：都可以在同一行，并且为块元素，可以自由设置宽高
2. 不同点：float脱离文档流
inline-block在文档流中，避免dom重绘
```
# 16.CSS 多列等高如何实现？
```js
（1）利用padding-bottom|margin-bottom正负值相抵，不会影响页面布局的特点。设置父容器设置超出隐藏（overflow:
hidden），这样父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则
父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。
.Article {
  overflow: hidden;
}

.Article>li {
  float: left;
  margin: 0 10px -9999px 0;
  padding-bottom: 9999px;
  background: #4577dc;
  width: 200px;
  color: #fff;
}

.Article>li>p {
  padding: 10px;
}
（2）利用table-cell所有单元格高度都相等的特性，来实现多列等高。
（3）利用flex布局中项目align-items属性默认为stretch，如果项目未设置高度或设为auto，将占满整个容器的高度
的特性，来实现多列等高。
（4）grid布局
.Article {
  display: grid;
  grid-auto-flow: column;
  grid-gap: 20px;
}

.Article>li {
  border-left: solid 5px currentColor;
  border-right: solid 5px currentColor;
  color: #fff;
  background: #4577dc;
}

.Article>li>p {
  padding: 10px;
}
```
# 17.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用 hack 的技巧？
```js
（1）png24位的图片在iE6浏览器上出现背景
解决方案：做成PNG8，也可以引用一段脚本处理。

（2）浏览器默认的margin和padding不同
解决方案：加一个全局的*{margin:0;padding:0;}来统一。

（3）IE6双边距bug：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或
margin-right，margin值会加倍。

#box{float:left;width:10px;margin:00010px;}

这种情况之下IE会产生20px的距离
解决方案：在float的标签样式控制中加入_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)

（4）渐进识别的方式，从总体中逐渐排除局部。
首先，巧妙的使用"\9"这一标记，将IE游览器从所有情况中分离出来。
接着，再次使用"+"将IE8和IE7、IE6分离开来，这样IE8已经独立识别。
.bb{
background-color:#f1ee18;/*所有识别*/
.background-color:#00deff\9;/*IE6、7、8识别*/
+background-color:#a200ff;/*IE6、7识别*/
_background-color:#1e0bd1;/*IE6识别*/
}

（5）IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义
属性；Firefox下，只能使用getAttribute()获取自定义属性
解决方法：统一通过getAttribute()获取自定义属性。

（6）IE下，event对象有x、y属性，但是没有pageX、pageY属性;Firefox下，event对象有
pageX、pageY属性，但是没有x、y属性。
解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。

（7）Chrome中文界面下默认会将小于12px的文本强制按照12px显示
解决方法：

1.可通过加入CSS属性-webkit-text-size-adjust:none;解决。但是，在chrome
更新到27版本之后就不可以用了。

2.还可以使用-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);
收缩的是整个span的大小，这时候，必须要将span转换成块元素，可以使用display：block/inline-block/...；

（8）超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了
解决方法：改变CSS属性的排列顺序L-V-H-A

（9）怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模
式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。
```
# 18.li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？
```js
浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个<li>放在一行，
这导致<li>换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。

解决办法：
（1）为<li>设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。
（2）将所有<li>写在同一行。不足：代码不美观。
（3）将<ul>内的字符尺寸直接设为0，即font-size:0。不足：<ul>中的其他字符尺寸也被设为0，需要额外重新设定其他
字符尺寸，且在Safari浏览器依然会出现空白间隔。
（4）消除<ul>的字符间隔letter-spacing:-8px，不足：这也设置了<li>内的字符间隔，因此需要将<li>内的字符
间隔设为默认letter-spacing:normal。
```
# 20.什么是包含块，对于包含块的理解?
```js
包含块（containingblock）就是元素用来计算和定位的一个框。
（1）根元素（很多场景下可以看成是<html>）被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。
（2）对于其他元素，如果该元素的position是relative或者static，则“包含块”由其最近的块容器祖先盒的contentbox
边界形成。
（3）如果元素position:fixed，则“包含块”是“初始包含块”。
（4）如果元素position:absolute，则“包含块”由最近的position不为static的祖先元素建立，具体方式如下：
如果该祖先元素是纯inline元素，则规则略复杂：
•假设给内联元素的前后各生成一个宽度为0的内联盒子（inlinebox），则这两个内联盒子的paddingbox外面的包
围盒就是内联元素的“包含块”；
•如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是CSS2.1规范并没有明确定义，浏览器自行发挥
否则，“包含块”由该祖先的paddingbox边界形成。

如果没有符合条件的祖先元素，则“包含块”是“初始包含块”。
```
# 21.CSS 里的 visibility 属性有个 collapse 属性值是干嘛用的？在不同浏览器下以后什么区别？
```js
在不同浏览器下的区别：
在谷歌浏览器里，使用collapse值和使用hidden值没有什么区别。
在火狐浏览器、Opera和IE11里，使用collapse值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位
置。
```
# 22.width:auto 和 width:100%的区别
```js
width:100% 会使元素box的宽度等于父元素的contentbox的宽度。
width:auto 会使元素撑满整个父元素，margin、border、padding、content区域会自动分配水平空间。
```
# 23.绝对定位元素与非绝对定位元素的百分比计算的区别
```js
绝对定位元素的宽高百分比是相对于临近的position不为static的祖先元素的paddingbox来计算的。
非绝对定位元素的宽高百分比则是相对于父元素的contentbox来计算的。
```
# 24. 'display'、'position' 和 'float' 的相互关系
```js
1. 'display'、'position' 和 'float' 的相互关系
  1.1  "position:absolute" 和 "position:fixed" 优先级最高，有它存在的时候，浮动不起作用，'display' 的值也需要调整； 
  1.2  元素的 'float' 特性的值不是 "none" 的时候或者它是根元素的时候，调整 'display' 的值；
  1.3  非根元素，并且非浮动元素，并且非绝对定位的元素，'display' 特性值同设置值
  `浮动或绝对定位的元素，只能是块元素或表格。`
```
# 26.margin 重叠问题的理解。
```js
块级元素的上外边距（margin-top）与下外边距（margin-bottom）有时会合并为单个外边距，这样的现象称为“margin合并”。
产生折叠的必备条件：margin必须是邻接的!,一般是垂直方向上和相邻元素的margin重叠。
1. 相邻兄弟元素margin合并。
解决方法：设置其中一个为BFC
2. 父元素的margin-top和子元素的margin-top发生重叠
对于margin-top合并，可以进行如下操作（满足一个条件即可）：
• 父元素设置为块状格式化上下文元素；
• 父元素设置border-top值；
• 父元素设置padding-top值；
• 父元素和第一个子元素之间添加内联元素进行分隔。
对于margin-bottom合并，可以进行如下操作（满足一个条件即可）：
• 父元素设置为块状格式化上下文元素；
• 父元素设置border-bottom值；
• 父元素设置padding-bottom值；
• 父元素和最后一个子元素之间添加内联元素进行分隔；
• 父元素设置height、min-height或max-height。
3. 空块级元素的margin合并。
解决办法：
•设置垂直方向的border；
•设置垂直方向的padding；
•里面添加内联元素（直接Space键空格是没用的）；
•设置height或者min-height。
4. 高度为auto的父元素的margin-bottom和子元素的margin-bottom发生重叠
解决方法：
父元素设置border-bottom、padding-bottom来分隔
父元素设置一个高度，max-height和min-height。
父元素设置为BFC是最简单的方法。
```
# 27.对 BFC 规范（块级格式化上下文：blockformattingcontext）的理解？
```js
// BFC中的元素布局不受外部影响。
创建BFC:
浮动和绝对定位的元素，
display属性的值为inline-block|flex|inline-flex|table-cell或table-caption
overflow的值不为visible
BFC的作用：
1. 利用BFC避免margin重叠，外边距重叠
2. 自适应两栏布局
3. 清除浮动
```
# 28.IFC 是什么？
```js
IFC指的是行级格式化上下文，它有这样的一些布局规则：
（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。
（2）当一行不够的时候会自动切换到下一行。
（3）行级上下文的高度由内部最高的内联盒子的高度决定。
```
# 29.清除浮动
```js
// 出现的情况：在非IE浏览器（如Firefox）下，当容器的高度为auto，且容器的内容中有浮动（float为left或right）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。
1.clear 
.clear::after{
  content:'';
  display:table;//也可以是'block'，或者是'list-item'
  clear:both;
}
// 在html后边加一个空元素设置clear:both
2. overflow(容器增加)
  overflow: hidden|auto;
  *zoom: 1;  //IE
3. 给浮动的元素的容器添加浮动
```
# 30. 响应式布局
```js
响应式布局：不同屏幕分辨率的终端上浏览网页的不同展示方式
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
@media screen and (max-width: 980px) {
  #head { … }
  #content { … }
  #footer { … }
}
1. 媒体查询
3. 例如 pre ，iframe，video 等，都需要和img一样控制好宽度。对于table，建议不要增加 padding 属性，低分辨率下使用内容居中：
4. 百分比布局
5. rem布局
4. 视口单位 vw/vh vmin vmax
5. 图片响应式
  1. 使用max-width（图片自适应）
  img {
    display: inline-block;
    max-width: 100%;
    height: auto;
  }
  2. 使用srcset
  <img srcset="photo_w350.jpg 1x, photo_w640.jpg 2x" src="photo_w350.jpg" >
  3. 使用background-image
  banner{
    background-image: url(/static/large.jpg);
  }
  @media screen and (max-width: 767px){
    background-image: url(/static/small.jpg);
  }
  4. 使用picture标签
  <picture>
    <source srcset="banner_w1000.jpg" media="(min-width: 801px)">
    <source srcset="banner_w800.jpg" media="(max-width: 800px)">
    <img src="banner_w800.jpg" alt="">
  </picture>
  <!-- picturefill.min.js 解决IE等浏览器不支持 <picture> 的问题 -->
  <script type="text/javascript" src="js/vendor/picturefill.min.js"></script>
```
# 36.在网页中应该使用奇数还是偶数的字体？为什么呢？
```js
// 使用偶数（大多数）：
1. 比例
2. 浏览器
3. 系统差别
// 使用奇数
1. 使用奇数号字体不好的地方是，文本段落无法对齐。
2. -webkit-text-size-adjust: none; 解决失效问题
只对chrome27.0 版本以下有效，27.0以上版本无效；
只对英文才有效，对中文无效。
3. transform:scale(0.7); 改变字体的大小
```
# 37.margin 和 padding 分别适合什么场景使用？
```js
何时应当使用margin：
•需要在border外侧添加空白时。
•空白处不需要背景（色）时。
•上下相连的两个盒子之间的空白，需要相互抵消时。如15px+20px的margin，将得到20px的空白。

何时应当时用padding：
•需要在border内测添加空白时。
•空白处需要背景（色）时。
•上下相连的两个盒子之间的空白，希望等于两者之和时。如15px+20px的padding，将得到35px的空白。
```
# 38.抽离样式模块怎么写，说出思路，有无实践经验？
```js
将CSS文件分成“公共型样式”、“特殊型样式”、“皮肤型样式”，并以此顺序引用（按需求决定是否添加版本号）。
```
# 39.简单说一下 css3 的 all 属性。
```js
all属性实际上是所有CSS属性的缩写，表示，所有的CSS属性都怎样怎样，但是，不包括unicode-bidi和direction
这两个CSS属性。支持三个CSS通用属性值，initial,inherit,unset。
initial是初始值的意思，也就是该元素元素都除了unicode-bidi和direction以外的CSS属性都使用属性的默认初始
值。
inherit是继承的意思，也就是该元素除了unicode-bidi和direction以外的CSS属性都继承父元素的属性值。
unset是取消设置的意思，也就是当前元素浏览器或用户设置的CSS忽略，然后如果是具有继承特性的CSS，如color，则
使用继承值；如果是没有继承特性的CSS属性，如background-color，则使用初始值。
```
# 42.对于 hasLayout 的理解？
```js
hasLayout是IE特有的一个属性。很多的ie下的css bug都与其息息相关。在ie中，一个元素要么自己对自身的内容进行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。当一个元素的hasLayout属性值为true时，它负责对自己和可能的子孙元素进行尺寸计算和定位。
在IE浏览器中下列默认hasLayout=true的元素
<table> <td> <body> <img> <hr> <input> <select> <textarea> <button> <iframe> <embed> <object> <applet> <marquee>
触发hasLayout的css
position: absolute (取消使用：static)
float: left or right(取消使用：none)
display: inline-block (取消使用：其它值)
width: 除了auto以外的值(取消使用：auto)
height: 除了auto以外的值(取消使用：auto)
zoom: 有值(取消使用：normal或者空值)
min-height: (网上查看说是任何值，但实践发现还是除了none与auto)
max-height: (任何值除了none与auto)
min-width: (网上查看说是任何值，但实践发现还是除了none与auto)
max-width: (任何值除了none与auto)
overflow: (任何值除了visible)
overflow-x: (任何值除了visible)
overflow-y: (任何值除了visible)
position: fixed
```
# 43.全屏滚动
https://blog.csdn.net/liona_koukou/article/details/52680409
# 47.如何修改 chrome 记住密码后自动填充表单的黄色背景？
```css
input:-webkit-autofill,textarea:-webkit-autofill,select:-webkit-autofill{
-webkit-box-shadow:000px1000pxwhiteinset;
border:1pxsolid#CCC!important;
}
```
# 48.怎么让 Chrome 支持小于 12px 的文字？
```js
解决办法：
（1）可以使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size
-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器
已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。
（2）还可以使用css3的transform缩放属性-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.
75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block/
inline-block/...；
（3）使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。
```
# 49.让页面里的字体变清晰，变细用 CSS 怎么做？
```js
-webkit-font-smoothing
在MacOS测试环境下面设置-webkit-font-smoothing:antialiased;但是这个属性仅仅是面向MacOS，其他操作系统设
置后无效。，
```
# 50.font-style 属性中 italic 和 oblique 的区别？
italic是使用当前字体的斜体字体，而oblique只是单纯地让文字倾斜。如果当前字体没有对应的斜体字体，则退而求其次，解析为oblique，也就是单纯形状倾斜。.
# 51.设备像素、css 像素、设备独立像素、dpr、ppi 之间的区别？
```js
1. 设备像素(device pixel, dp): 又称为物理像素。指设备能控制显示的最小物理单位，意指显示器上一个个的点
2. CSS像素(css pixel, px): 又称为虚拟像素，也可以理解为直觉像素
px 是一个相对单位，而且在特定设备上总是一个近似值
每英寸像素(pixel per inch, ppi/PPI): 它表示的是每英寸所拥有的像素(pixel)数目。
设备像素比(device pixel ratio, dpr/DPR): 它描述的是未缩放状态下，设备像素和 CSS 像素的初始比例关系，也可以解释为默认缩放比例。
`DPI`: 每英寸多少点。
```
# 52.layoutviewport、visualviewport 和 idealviewport 的区别？
```js
`layoutviewport`:宽度是大于浏览器可视区域的宽度的
`visualviewport`:代表浏览器可视区域的大小
`idealviewport`:最适合移动设备的viewport
```
# 53.position:fixed;在 android 下无效怎么处理？
```js
<metaname="viewport"content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=no"/>
```
# 55.如何让去除 inline-block 元素间间距？
```js
移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing
```
# 56.overflow:scroll 时不能平滑滚动的问题怎么处理？
-webkit-overflow-scrolling:touch;
# 57.有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。
```js
 /*方案一*/
.outer { height: 100%; padding: 100px 0 0; box-sizing: border-box ; }
.A { height: 100px; margin: -100px 0 0; background: #BBE8F2; }
.B { height: 100%; background: #D9C666; }
 
/*方案二*/
.outer { height: 100%; padding: 100px 0 0; box-sizing: border-box ; position: relative; }
.A { height: 100px; background: #BBE8F2; position: absolute; top: 0 ; left: 0 ; width: 100%; }
.B { height: 100%; background: #D9C666; }

/*方案三*/
.outer { height: 100%; position: relative; }
.A { height: 100px; background: #BBE8F2; }
.B { background: #D9C666; width: 100%; position: absolute; top: 100px ; left: 0 ; bottom: 0; }
```
# 58.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？
```js
（1）BMP，是无损的、既支持索引色也支持直接色的、点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常
具有较大的文件大小。
（2）GIF是无损的、采用索引色的、点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具
有支持动画以及透明的优点。但，GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积
较小的场景。
（3）JPEG是有损的、采用直接色的、点阵图。JPEG的图片的优点，是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来
存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，
又会导致图片文件较GIF更大。
（4）PNG-8是无损的、使用索引色的、点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的
情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8
还支持透明度的调节，而GIF并不支持。现在，除非需要动画的支持，否则我们没有理由使用GIF而不是PNG-8。
（5）PNG-24是无损的、使用直接色的、点阵图。PNG-24的优点在于，它压缩了图片的数据，使得同样效果的图片，PNG-24格
式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。
（6）SVG是无损的、矢量图。SVG是矢量图。这意味着SVG图片由直线和曲线以及绘制它们的方法组成。当你放大一个SVG图
片的时候，你看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制企
业Logo、Icon等。
（7）WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的、点阵图。从名字就可以看出来它是
为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，
如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。
•在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；
•在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；
•WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。
但是目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。
```
# 59.浏览器如何判断是否支持 webp 格式图片
```js
（1）宽高判断法。通过创建image对象，将其src属性设置为webp格式的图片，然后在onload事件中获取图片的宽高，如
果能够获取，则说明浏览器支持webp格式图片。如果不能获取或者触发了onerror函数，那么就说明浏览器不支持webp格
式的图片。
（2）canvas判断方法。我们可以动态的创建一个canvas对象，通过canvas的toDataURL将设置为webp格式，然后判断
返回值中是否含有image/webp字段，如果包含则说明支持WebP，反之则不支持。
```
# 60.什么是 Cookie 隔离？（或者说：请求资源的时候不要让它带 cookie 怎么做）
```js
网站向服务器请求的时候，会自动带上cookie这样增加表头信息量，使请求变慢。
如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开
，静态资源放CDN。
因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请
求头的大小，降低请求时间，从而达到降低整体请求延时的目的。
同时这种方式不会将cookie传入WebServer，也减少了WebServer对cookie的处理分析环节，提高了webserver的
http请求的解析速度。
```
# 61.style 标签写在 body 后与 body 前有什么区别？
```js
页面加载自上而下当然是先加载样式。写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式
表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可
能会出现FOUC现象（即样式失效导致的页面闪烁问题）
```
# 62.什么是 CSS 预处理器/后处理器？
```js
`CSS预处理器`用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件。
预处理器例如：LESS、Sass、Stylus，用来预编译Sass或lesscsssprite，增强了css代码的复用性，还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。
`CSS后处理器`：如PostCSS、Rework，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。
可以通过js对css进行编辑。
```
# 63.阐述一下 CSSSprites
```js
将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的background-image，background-repeat，background
-position的组合进行背景定位。利用CSSSprites能很好地减少网页的http请求，从而很好的提高页面的性能；CSSSprites
能减少图片的字节。

优点：
减少HTTP请求数，极大地提高页面加载速度
增加图片信息重复度，提高压缩比，减少图片大小
更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现

缺点：
图片合并麻烦
维护麻烦，修改一个图片可能需要重新布局整个图片，样式
```
# 64.使用 rem 布局的优缺点？
```js
优点：
在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。
而且现在浏览器基本都已经支持rem了，兼容性也非常的好。

缺点：
（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。
（2）使用iframe引用也会出现问题。
（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题。
（4）需要解决在ios上的1px边框问题，但是这个在lib-flexible中已经解决：（1px变2px， 又被 initial-scale=0.5 缩小了一半）
```
# 65.几种常见的 CSS 布局
```js
1. 单列布局
header,content和footer等宽的单列布局
<div class="header"></div>
<div class="content"></div>
<div class="footer"></div>
.header{
    margin:0 auto; 
    max-width: 960px;
    height:100px;
    background-color: blue;
}
.content{
    margin: 0 auto;
    max-width: 960px;
    height: 400px;
    background-color: aquamarine;
}
.footer{
    margin: 0 auto;
    max-width: 960px;
    height: 100px;
    background-color: aqua;
}
header与footer等宽,content略窄的单列布局
<div class="header">
    <div class="nav"></div>
</div>
<div class="content"></div>
<div class="footer"></div>
.header{
    margin:0 auto;
    max-width: 960px;
    height:100px;
    background-color: blue;
}
.nav{
    margin: 0 auto;
    max-width: 800px;
    background-color: darkgray;
    height: 50px;
}
.content{
    margin: 0 auto;
    max-width: 800px;
    height: 400px;
    background-color: aquamarine;
}
.footer{
    margin: 0 auto;
    max-width: 960px;
    height: 100px;
    background-color: aqua;
}
```
```js
 两列自适应布局
1. float+overflow:hidden
.parent {
  overflow: hidden;
  zoom: 1;
}
.left {
  float: left;
  margin-right: 20px;
}
.right {
  overflow: hidden;
  zoom: 1;
}
2. Flex布局
.parent {
  display:flex;
}  
.right {
  margin-left:20px; 
  flex:1;
}
3. grid布局
.parent {
  display:grid;
  grid-template-columns:auto 1fr;
  grid-gap:20px
} 
```
```js
三栏布局(两边固定，中间自适应)
1. 圣杯布局
两边固定宽度，中间自适应,唯一区别是dom结构必须是先写中间列部分，这样实现中间列可以优先加载。
缺点：center部分的最小宽度不能小于left部分的宽度，否则会left部分掉到下一行，如果其中一列内容高度拉长(如下图)，其他两列的背景并不会自动填充。(借助等高布局正padding+负margin可解决，下文会介绍)
.container {
    padding-left: 220px;//为左右栏腾出空间
    padding-right: 220px;
  }
  .left {
    float: left;
    width: 200px;
    height: 400px;
    background: red;
    margin-left: -100%;
    position: relative;
    left: -220px;
  }
  .center {
    float: left;
    width: 100%;
    height: 500px;
    background: yellow;
  }
  .right {
    float: left;
    width: 200px;
    height: 400px;
    background: blue;
    margin-left: -200px;
    position: relative;
    right: -220px;
  }
2. 双飞翼布局
   缺点:多加一层 dom 树节点，增加渲染树生成的计算量。
    .container {
        min-width: 600px;//确保中间内容可以显示出来，两倍left宽+right宽
    }
    .left {
        float: left;
        width: 200px;
        height: 400px;
        background: red;
        margin-left: -100%;
    }
    .center {
        float: left;
        width: 100%;
        height: 500px;
        background: yellow;
    }
    .center .inner {
        margin: 0 200px; //新增部分
    }
    .right {
        float: left;
        width: 200px;
        height: 400px;
        background: blue;
        margin-left: -200px;
    }
3. 浮动。左边左浮动，右边右浮动
4. 绝对布局。左边采用left:0,右边采用right:0   （两侧高度无法支撑总高度）
5. flex布局。中间设置flex:1,左右固定宽度
6. 表格布局。采用display:table和display:table-cell
7. 网格布局。
.container{
  display: grid;
  width: 100%;
  grid-template-columns: 300px auto 300px;
  grid-template-rows: 150px;//行高
}
```
```js
等高布局
1.利用正padding+负margin
.center,
.left,
.right {
  padding-bottom: 10000px;
  margin-bottom: -10000px;
}
.container {
  padding-left: 220px;
  padding-right: 220px;
  overflow: hidden;//把溢出背景切掉
}
2. 利用背景图片
.container {
  background: url("column.png") repeat-y;
  width: 960px;
  margin: 0 auto;
}
.left {
  float: left;
  width: 220px;
}
.content {
  float: left;
  width: 480px;
}
.right {
  float: left;
  width: 220px;
}
3. 模仿表格布局 （不过兼容性不好，在ie6-7无法正常运行。）
<div class="container table">
      <div class="containerInner tableRow">
        <div class="column tableCell cell1">
          <div class="left aside">
            ....
          </div>
        </div>
        <div class="column tableCell cell2">
          <div class="content section">
            ...
          </div>
        </div>
        <div class="column tableCell cell3">
          <div class="right aside">
            ...
          </div>
        </div>
      </div>
    </div>
.table {
  width: auto;
  min-width: 1000px;
  margin: 0 auto;
  padding: 0;
  display: table;
}
.tableRow {
  display: table-row;
}
.tableCell {
  display: table-cell;
  width: 33%;
}
.cell1 {
  background: #f00;
  height: 800px;
}
.cell2 {
  background: #0f0;
}
.cell3 {
  background: #00f;
}
4. 使用边框和定位
#wrapper {
  width: 960px;
  margin: 0 auto;
}
#mainContent {
  border-right: 220px solid #dfdfdf;
  position: absolute;
  width: 740px;
  height: 800px;  
  background: green;
}
#sidebar {
  background: #dfdfdf;
  margin-left: 740px;
  position: absolute;
  height: 800px;
  width: 220px;
}
<div id="wrapper">
    <div id="mainContent">...</div>
    <div id="sidebar">...</div>
</div>
```
```js
粘连布局
特点：有一块内容<main>，当<main>的高康足够长的时候，紧跟在<main>后面的元素<footer>会跟在<main>元素的后面。
      当<main>元素比较短的时候(比如小于屏幕的高度),我们期望这个<footer>元素能够“粘连”在屏幕的底部
<div id="wrap">
<div class="main">
  main <br />
  main <br />
  main <br />
</div>
</div>
<div id="footer">footer</div>
* {
      margin: 0;
      padding: 0;
    }
    html,
    body {
      height: 100%;//高度一层层继承下来
    }
    #wrap {
      min-height: 100%;
      background: pink;
      text-align: center;
      overflow: hidden;
    }
    #wrap .main {
      padding-bottom: 50px;
    }
    #footer {
      height: 50px;
      line-height: 50px;
      background: deeppink;
      text-align: center;
      margin-top: -50px;
    }
```
# 66.画一条 0.5px 的线
```js
1. transform: scaleY(0.5); transform-origin: 50% 100%;
2. background: linear-gradient(0deg, #fff, #000);
3. background: none;
   box-shadow: 0 0.5px 0 #000;
4. background: url("data:image/svg+xml;utf-8,<svg xmlns='http://www.w3.org/2000/svg' width='100%' height='1px'><line x1='0' y1='0' x2='100%' y2='0' stroke='#000'></line></svg>");
```
# 67.transition 和 animation 的区别
```js
transition关注的是CSSproperty的变化，property值和时间的关系是一个三次贝塞尔曲线。
animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果
```
# 68.什么是首选最小宽度？
```js
“首选最小宽度”，指的是元素最适合的最小宽度。
东亚文字（如中文）最小宽度为每个汉字的宽度。
西方文字最小宽度由特定的连续的英文字符单元决定。并不是所有的英文字符都会组成连续单元，一般会终止于空格（普通空格）、短
横线、问号以及其他非英文字符等。
如果想让英文字符和中文一样，每一个字符都用最小宽度单元，可以试试使用CSS中的word-break:break-all。
```
# 69.为什么 height:100%会无效？
```js
对于普通文档流中的元素，百分比高度值要想起作用，其父级必须有一个可以生效的高度值。
原因是如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto，因为解释成了auto，
所以无法参与计算。
使用绝对定位的元素会有计算值，即使祖先元素的height计算为auto也是如此。
```
# 70.min-width/max-width 和 min-height/max-height 属性间的覆盖规则？
```js
（1）max-width会覆盖width，即使width是行类样式或者设置了!important。
（2）min-width会覆盖max-width，此规则发生在min-width和max-width冲突的时候。
```
# 71.内联盒模型基本概念
```js
（1）内容区域（contentarea）。内容区域指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子
（characterbox）；但是有些元素，如图片这样的替换元素，其内容显然不是文字，不存在字符盒子之类的，因此，对于这些
元素，内容区域可以看成元素自身。

（2）内联盒子（inlinebox）。“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒
子”，用来决定元素是内联还是块级。该盒子又可以细分为“内联盒子”和“匿名内联盒子”两类。

（3）行框盒子（linebox），每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。

（4）包含块（containingbox），由一行一行的“行框盒子”组成。
```
# 72.什么是幽灵空白节点？
```js
“幽灵空白节点”是内联盒模型中非常重要的一个概念，具体指的是：在HTML5文档声明中，内联元素的所有解析和渲染表现就如同
每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，就好像幽灵
一样，但又确确实实地存在，表现如同文本节点一样，因此，我称之为“幽灵空白节点”。
```
# 73.什么是替换元素？
```js
通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。因此，<img>、<object>、<video>、<iframe>或者表
单元素<textarea>和<input>和<select>都是典型的替换元素。

替换元素除了内容可替换这一特性以外，还有以下一些特性。

（1）内容的外观不受页面上的CSS的影响。用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要
类似appearance属性，或者浏览器自身暴露的一些样式接口，

（2）有自己的尺寸。在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像
素，如<video>、<iframe>或者<canvas>等，也有少部分替换元素为0像素，如<img>图片，而表单元素的替换元素
的尺寸则和浏览器有关，没有明显的规律。

（3）在很多CSS属性上有自己的一套表现规则。比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，ve
rtical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，
被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。

（4）所有的替换元素都是内联水平元素，也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认
的display值却是不一样的，有的是inline，有的是inline-block。
```
# 74.替换元素的计算规则？
```js
替换元素的尺寸从内而外分为3类：固有尺寸、HTML尺寸和CSS尺寸。

（1）固有尺寸指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。

（2）HTML尺寸只能通过HTML原生属性改变，这些HTML原生属性包括<img>的width和height属性、<input>的s
ize属性、<textarea>的cols和rows属性等。

（3）CSS尺寸特指可以通过CSS的width和height或者max-width/min-width和max-height/min-height设置的
尺寸，对应盒尺寸中的contentbox。

这3层结构的计算规则具体如下

（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。

（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。

（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。

（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。

（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。

（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。
```
# 75.content 与替换元素的关系？
```js
content属性生成的对象称为“匿名替换元素”。

（1）我们使用content生成的文本是无法选中、无法复制的，好像设置了userselect:none声明一般，但是普通元素的文本
却可以被轻松选中。同时，content生成的文本无法被屏幕阅读设备读取，也无法被搜索引擎抓取，因此，千万不要自以为是
地把重要的文本信息使用content属性生成，因为这对可访问性和SEO都很不友好。

（2）content生成的内容不能左右:empty伪类。

（3）content动态生成值无法获取。
```
# 76.margin:auto 的填充规则？
```js
margin的'auto'可不是摆设，是具有强烈的计算意味的关键字，用来计算元素对应方向应该获得的剩余间距大小。但是触发mar
gin:auto计算有一个前提条件，就是width或height为auto时，元素是具有对应方向的自动填充特性的。

（1）如果一侧定值，一侧auto，则auto为剩余空间大小。
（2）如果两侧均是auto，则平分剩余空间。
```
# 77.margin 无效的情形
```js
1）display计算值inline的非替换元素的垂直margin是无效的。对于内联替换元素，垂直margin有效，并且没有ma
rgin合并的问题。

（2）表格中的<tr>和<td>元素或者设置display计算值是table-cell或table-row的元素的margin都是无效的。

（3）绝对定位元素非定位方位的margin值“无效”。

（4）定高容器的子元素的margin-bottom或者宽度定死的子元素的margin-right的定位“失效”。
```
# 78.border 的特殊性？
```js
（1）border-width却不支持百分比。

（2）border-style的默认值是none，有一部分人可能会误以为是solid。这也是单纯设置border-width或border-col
or没有边框显示的原因。

（3）border-style:double的表现规则：双线宽度永远相等，中间间隔±1。

（4）border-color默认颜色就是color色值。

（5）默认background背景图片是相对于paddingbox定位的。
```
# 79.什么是基线和 x-height？
```js
字母x的下边缘（线）就是我们的基线。

x-height指的就是小写字母x的高度，术语描述就是基线和等分线（meanline）（也称作中线，midline）之间的距离。在C
SS世界中，middle指的是基线往上1/2x-height高度。我们可以近似理解为字母x交叉点那个位置。

ex是CSS中的一个相对单位，指的是小写字母x的高度，没错，就是指x-height。ex的价值就在其副业上不受字体和字号影
响的内联元素的垂直居中对齐效果。内联元素默认是基线对齐的，而基线就是x的底部，而1ex就是一个x的高度。
```
# 80.line-height 的特殊性？
```js
（1）对于非替换元素的纯内联元素，其可视高度完全由line-height决定。对于文本这样的纯内联元素，line-height就是高
度计算的基石，用专业说法就是指定了用来计算行框盒子高度的基础高度。

（2）内联元素的高度由固定高度和不固定高度组成，这个不固定的部分就是这里的“行距”。换句话说，line-height之所以起作
用，就是通过改变“行距”来实现的。在CSS中，“行距”分散在当前文字的上方和下方，也就是即使是第一行文字，其上方也是
有“行距”的，只不过这个“行距”的高度仅仅是完整“行距”高度的一半，因此，也被称为“半行距”。

（3）行距=line-height-font-size。

（4）border以及line-height等传统CSS属性并没有小数像素的概念。如果标注的是文字上边距，则向下取整；如果是文字下
边距，则向上取整。

（5）对于纯文本元素，line-height直接决定了最终的高度。但是，如果同时有替换元素，则line-height只能决定最小高度。

（6）对于块级元素，line-height对其本身是没有任何作用的，我们平时改变line-height，块级元素的高度跟着变化实际上是
通过改变块级元素里面内联级别元素占据的高度实现的。

（7）line-height的默认值是normal，还支持数值、百分比值以及长度值。为数值类型时，其最终的计算值是和当前font-si
ze相乘后的值。为百分比值时，其最终的计算值是和当前font-size相乘后的值。为长度值时原意不变。

（8）如果使用数值作为line-height的属性值，那么所有的子元素继承的都是这个值；但是，如果使用百分比值或者长度值作为
属性值，那么所有的子元素继承的是最终的计算值。

（9）无论内联元素line-height如何设置，最终父级元素的高度都是由数值大的那个line-height决定的。

（10）只要有“内联盒子”在，就一定会有“行框盒子”，就是每一行内联元素外面包裹的一层看不见的盒子。然后，重点来了，在每个
“行框盒子”前面有一个宽度为0的具有该元素的字体和行高属性的看不见的“幽灵空白节点”。
```
# 81.vertical-align 的特殊性？
```js
（1）vertical-align的默认值是baseline，即基线对齐，而基线的定义是字母x的下边缘。因此，内联元素默认都是沿着字
母x的下边缘对齐的。对于图片等替换元素，往往使用元素本身的下边缘作为基线。：一个inline-block元素，如果里面
没有内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘；否则其基线就是元素里面最后一行
内联元素的基线。

（2）vertical-align:top就是垂直上边缘对齐，如果是内联元素，则和这一行位置最高的内联元素的顶部对齐；如果display
计算值是table-cell的元素，我们不妨脑补成<td>元素，则和<tr>元素上边缘对齐。

（3）vertical-align:middle是中间对齐，对于内联元素，元素的垂直中心点和行框盒子基线往上1/2x-height处对齐。对
于table-cell元素，单元格填充盒子相对于外面的表格行居中对齐。

（4）vertical-align支持数值属性，根据数值的不同，相对于基线往上或往下偏移，如果是负值，往下偏移，如果是正值，往上
偏移。

（5）vertical-align属性的百分比值则是相对于line-height的计算值计算的。

（6）`vertical-align起作用是有前提条件的，这个前提条件就是：只能应用于内联元素以及display值为table-cell的元
素。`

（7）table-cell元素设置vertical-align垂直对齐的是子元素，但是其作用的并不是子元素，而是table-cell元素自身。
```
# 82.overflow 的特殊性？
```js
（1）一个设置了overflow:hidden声明的元素，假设同时存在border属性和padding属性，则当子元素内容超出容器宽度
高度限制的时候，剪裁的边界是borderbox的内边缘，而非paddingbox的内边缘。

（2）HTML中有两个标签是默认可以产生滚动条的，一个是根元素<html>，另一个是文本域<textarea>。

（3）滚动条会占用容器的可用宽度或高度。

（4）元素设置了overflow:hidden声明，里面内容高度溢出的时候，滚动依然存在，仅仅滚动条不存在！
```
# 83.无依赖绝对定位是什么？
```js
没有设置left/top/right/bottom属性值的绝对定位称为“无依赖绝对定位”。
无依赖绝对定位其定位的位置和没有设置position:absolute时候的位置相关。
```
# 84.absolute 与 overflow 的关系？
```js
（1）如果overflow不是定位元素，同时绝对定位元素和overflow容器之间也没有定位元素，则overflow无法对absolute
元素进行剪裁。
（2）如果overflow的属性值不是hidden而是auto或者scroll，即使绝对定位元素高宽比overflow元素高宽还要大，也
都不会出现滚动条。
（3）overflow元素自身transform的时候，Chrome和Opera浏览器下的overflow剪裁是无效的。
```
# 85.clip 裁剪是什么？
```js
所谓“可访问性隐藏”，指的是虽然内容肉眼看不见，但是其他辅助设备却能够进行识别和访问的隐藏。
clip剪裁被我称为“最佳可访问性隐藏”的另外一个原因就是，它具有更强的普遍适应性，任何元素、任何场景都可以无障碍使用。
```
# 86.relative 的特殊性？
```js
（1）相对定位元素的left/top/right/bottom的百分比值是相对于包含块计算的，而不是自身。注意，虽然定位位移是相对自身，但是百分比值的计算值不是。

（2）top和bottom这两个垂直方向的百分比值计算跟height的百分比值是一样的，都是相对高度计算的。同时，如果包含块的高度是auto，那么计算值是0，偏移无效，也就是说，如果父元素没有设定高度或者不是“格式化高度”，那么relative类似top:20%的代码等同于top:0。

（3）当相对定位元素同时应用对立方向定位值的时候，也就是top/bottom和left/right同时使用的时候，只有一个方向的定位属性会起作用。而谁起作用则是与文档流的顺序有关的，默认的文档流是自上而下、从左往右，因此top/bottom同时使用的时候，bottom失效；left/right同时使用的时候，right失效。
```
# 87.什么是层叠上下文？
```js
层叠上下文，英文称作stackingcontext，是HTML中的一个三维的概念。如果一个元素含有层叠上下文，我们可以理解为这个元
素在z轴上就“高人一等”。

层叠上下文元素有如下特性：

（1）层叠上下文的层叠水平要比普通元素高（原因后面会说明）。
（2）层叠上下文可以阻断元素的混合模式。
（3）层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。
（4）每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素。
（5）每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。


层叠上下文的创建：

（1）页面根元素天生具有层叠上下文，称为根层叠上下文。根层叠上下文指的是页面根元素，可以看成是<html>元素。因此，页面中所有的元素一定处于至少一个“层叠结界”中。

（2）对于position值为relative/absolute以及Firefox/IE浏览器（不包括Chrome浏览器）下含有position:fixed声明的定位元素，当其z-index值不是auto的时候，会创建层叠上下文。Chrome等WebKit内核浏览器下，position:fixed元素天然层叠上下文元素，无须z-index为数值。根据我的测试，目前IE和Firefox仍是老套路。

（3）其他一些CSS3属性，比如元素的opacity值不是1。
```
# 89.元素的层叠顺序？
```js
层叠上下文===》负z-index===>block块状水平盒子===》float浮动盒子===》inline水平盒子===》z-index：auto|0|不依赖zindex的层叠上下文===》正z-index(最高)
```
# 92.text-indent 的特殊性？
```js
（1）text-indent仅对第一行内联盒子内容有效。
（2）非替换元素以外的display计算值为inline的内联元素设置text-indent值无效，如果计算值inline-block/inline-table则会生效。
（3）<input>标签按钮text-indent值无效。
（4）<button>标签按钮text-indent值有效。
（5）text-indent的百分比值是相对于当前元素的“包含块”计算的，而不是当前元素。
```
# 93.letter-spacing 与字符间距？
```js
letter-spacing可以用来控制字符之间的间距，这里说的“字符”包括英文字母、汉字以及空格等。

letter-spacing具有以下一些特性。

（1）继承性。
（2）默认值是normal而不是0。虽然说正常情况下，normal的计算值就是0，但两者还是有差别的，在有些场景下，letter-spacing会调整normal的计算值以实现更好的版面布局。
（3）支持负值，且值足够大的时候，会让字符形成重叠，甚至反向排列。
（4）和text-indent属性一样，无论值多大或多小，第一行一定会保留至少一个字符。
（5）支持小数值，即使0.1px也是支持的。
（6）暂不支持百分比值。
```
# 94.word-spacing 与单词间距？
```js
letter-spacing作用于所有字符，但word-spacing仅作用于空格字符。换句话说，word-spacing的作用就是增加空格的间隙宽度。
```
# 95.white-space 与换行和空格的控制？
```js
white-space属性声明了如何处理元素内的空白字符，这类空白字符包括Space（空格）键、Enter（回车）键、Tab（制表符）
键产生的空白。因此，white-space可以决定图文内容是否在一行显示（回车空格是否生效），是否显示大段连续空白（空格是否
生效）等。

其属性值包括下面这些。
•normal：合并空白字符和换行符。
•pre：空白字符不合并，并且内容只在有换行符的地方换行。
•nowrap：该值和normal一样会合并空白字符，但不允许文本环绕。
•pre-wrap：空白字符不合并，并且内容只在有换行符的地方换行，同时允许文本环绕。
•pre-line：合并空白字符，但只在有换行符的地方换行，允许文本环绕。
```
# 96. 隐藏元素的 background-image 到底加不加载？
```js
（1）元素的背景图片
元素本身设置 display:none，会请求图片 
父级元素设置 display:none，不会请求图片 
样式没有元素使用，不会请求
:hover 样式下，触发时请求
（2）img 标签图片任何情况下都会请求图片
```
# 97.如何实现单行／多行文本溢出的省略（...）？
```js
/*单行文本溢出*/
p {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/*多行文本溢出*/
p {
  position: relative;
  line-height: 1.5em;
  /*高度为需要显示的行数*行高，比如这里我们显示两行，则为3*/
  height: 3em;
  overflow: hidden;
}

p:after {
  content: "...";
  position: absolute;
  bottom: 0;
  right: 0;
  background-color: #fff;
}
```
# 98.常见的元素隐藏方式？
```js
-（1）使用 display:none;隐藏元素，渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。
-（2）使用 visibility:hidden;隐藏元素。元素在页面中仍占据空间，但是不会响应绑定的监听事件。
-（3）使用 opacity:0;将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。
-（4）通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。
-（5）通过 z-index 负值，来使其他元素遮盖住该元素，以此来实现隐藏。
-（6）通过 clip/clip-path 元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。
-（7）通过 transform:scale(0,0)来将元素缩放为 0，以此来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。
```
# 99.css 实现上下固定中间自适应布局？
```js
1. 利用绝对定位实现
header top:0   container top:100px   footer: bottom:0
2. flex布局
flex-direction: column;  flex-grow:1
3. grid布局
  display:grid;
  grid-template-rows:100px auto 100px;
  grid-template-columns:100%
4. table布局
display:table;
display: table-row;
```
# 102.实现一个宽高自适应的正方形
```js
/*1.第一种方式是利用vw来实现*/
.square {
  width: 10%;
  height: 10vw;
  background: tomato;
}

/*2.第二种方式是利用元素的margin/padding百分比是相对父元素width的性质来实现*/
.square {
  width: 20%;
  height: 0;
  padding-top: 20%;
  background: orange;
}

/*3.第三种方式是利用子元素的margin-top的值来实现的*/
.square {
  width: 30%;
  overflow: hidden;
  background: yellow;
}

.square::after {
  content: "";
  display: block;
  margin-top: 100%;
}
```
# 104.一个自适应矩形，水平垂直居中，且宽高比为 2:1
```js
/*实现原理参考自适应正方形和水平居中方式*/
.box {
  position: absolute;
  top: 0;
  right: 0;
  left: 0;
  bottom: 0;
  margin: auto;

  width: 10%;
  height: 0;
  padding-top: 20%;
  background: tomato;
}
```
# 105.详解CSS中的百分比的应用
```js
1. width和height
父元素没有明确的高度定义,并且子元素使用百分比并且不是绝对定位，那么这时候的百分比等同于auto。
2. margin和padding
  1. 百分比的计算是基于其包含块的宽度
  2. 百分比的计算规则适用于margin和padding的四个方向
  3. 如果包含块的宽度取决于该元素，那么百分比的使用结果是未定义的。
3. border-radius
border-radius的百分比参考值是自身的尺寸
4. background-position
百分比：(父元素-背景图片)*百分比
5. font-size
百分比参考值是它的父元素的font-size
6. line-height
line-height这个属性的百分比参考的是自身的font-size大小
7. vertical-align
其参考值是自身的line-height
8. bottom、left、right、top
left和right是参照包含块的宽度，bottom和top是参照包含块的高度。
9. transform:translate
其自身元素的宽度或者高度,应该是border-box的尺寸
```
# 106. css函数
```js
1. attr() //用来选择元素的属性值，用法：attr(html元素的属性名)，正常搭配css content一起使用
2. calc()
3. var() //用于插入自定义属性
4. filter  //（ ，blur，brightness，contrast，grayscale，hue-rotate，opacity，invert，sepia，）
5. cubic-bezier()：定义Cubic Bezier曲线
6. hsl()：使用Hue-Saturation-Lightness模型（HSL）定义颜色 
   hlsa()
7. linear-gradient()：将线性渐变设置为背景图像。 定义至少两种颜色（从上到下）
   radial-gradient()：将径向渐变设置为背景图像。 定义至少两种颜色（中心到边缘）
8. repeating-linear-gradient()：重复线性渐变
   repeating-radial-gradient()：重复径向渐变rgb()使用红 - 绿 - 蓝模型（RGB）定义颜色
9. rgba()：使用Red-Green-Blue-Alpha模型（RGBA）定义颜色
```
# css的动画
```js
1. setTimeout setInterval
2. requestAnimaionFrame
3. css3
transform: 变化
transition: 过渡
```
